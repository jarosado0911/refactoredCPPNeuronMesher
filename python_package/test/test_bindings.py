"""
Test suite for the Python bindings of the NeuronGraph C++ library.

This module contains unit tests that verify the functionality of the Python bindings
for the NeuronGraph C++ library. It tests various operations including file I/O,
graph manipulation, and analysis functions.

Key Test Categories:
- Basic graph operations (node/edge counts, topology)
- File I/O (SWC and UGX formats)
- Graph preprocessing and manipulation
- Trunk extraction and reassembly
- Resampling and refinement operations
- File format conversion

Dependencies:
    pytest: Test framework
    rich: Enhanced terminal output formatting
    python_package.neurongraph: The Python bindings being tested

Usage:
    To run all tests:
        pytest test_bindings.py -v

    To run a specific test:
        pytest test_bindings.py::test_function_name -v

Notes:
    - Test data files are stored in the test/data directory
    - Output files are written to test/output
    - The test fixture 'graph' provides a pre-loaded NeuronGraph instance
"""

import pytest
import os
import inspect
from rich import print
from rich.table import Table
import python_package.neurongraph as ng

def get_test_data_path(filename):
    """
    Construct the full path to the test data file given its filename.

    Args:
        filename (str): The name of the test data file.

    Returns:
        str: The full path to the test data file located in the same directory as this script.
    """
    return os.path.join(os.path.dirname(__file__), filename)

def get_output_dir():
    """
    Construct the full path to the output directory.

    The output directory is used to store temporary files generated by
    the test suite. It is located in the parent directory of the directory
    containing this script.

    Returns:
        str: The full path to the output directory.
    """
    return os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'output'))

delta = 2.0

@pytest.fixture(scope="module")
def graph():
    """
    A fixture providing a neuron graph object from a test data file.

    This fixture provides a neuron graph object that has been initialized with data
    from a file in the test data directory. The fixture is scoped to the module,
    meaning that it is created once per module (i.e., once per test suite) and is
    reused across all tests in the module.

    The neuron graph object is created by calling the default constructor and
    then calling the readFromFile method with a file in the test data directory.
    The file is located in the same directory as the current script, and the full
    path is determined using the get_test_data_path function.

    Returns:
        A neuron graph object (ng.NeuronGraph) that has been initialized with data
        from the test data file.
    """
    g = ng.NeuronGraph()
    path = get_test_data_path("neuron.swc")
    g.readFromFile(path)
    return g

def test_initializer(graph):
    """
    Test the default initialization of a NeuronGraph object.

    This test verifies that a newly created NeuronGraph object has
    zero nodes immediately after initialization. It checks the initial
    state of the graph to ensure that no nodes are present.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    g0 = ng.NeuronGraph()
    print(f"\n[blue] TEST {fn}:[/] [green]Number of nodes:[/] {g0.numberOfNodes()}")
    assert g0.numberOfNodes() == 0

def test_initializer2(graph):
    """
    Test the initialization of a NeuronGraph object with a file path.

    This test verifies that a newly created NeuronGraph object can be initialized
    with a file path and that the object is populated with data from the file.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    infile= get_test_data_path("neuron.swc")
    g0 = ng.NeuronGraph(infile)
    print(f"\n[blue] TEST {fn}:[/] [green]Number of nodes:[/] {g0.numberOfNodes()}")
    assert g0.numberOfNodes()>0

def test_number_of_nodes(graph):
    """
    Test that the graph has the correct number of nodes.

    Verifies that the numberOfNodes() method returns the correct number of nodes
    in the graph. The correct number of nodes is determined by the number of
    nodes in the test data file.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    count = graph.numberOfNodes()
    print(f"\n[blue] TEST {fn}:[/] [green]Number of nodes:[/] {count}")
    assert count > 0

def test_number_of_edges(graph):
    """
    Test that the graph has the correct number of edges.

    Verifies that the numberOfEdges() method returns the correct number of edges
    in the graph. The correct number of edges is determined by the number of
    edges in the test data file.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    count = graph.numberOfEdges()
    print(f"\n[blue] TEST {fn}:[/] [green]Number of edges:[/] {count}")
    assert count > 0

def test_get_nodes(graph):
    """
    Test that the getNodes() method returns a dictionary of SWCNode objects.

    Verifies that the getNodes() method returns a dictionary where the keys are
    integers and the values are SWCNode objects.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    nodes = graph.getNodes()
    print(f"\n[blue] TEST {fn}:[/] [cyan]Got {len(nodes)} nodes[/]")
    assert isinstance(nodes, dict)
    assert all(isinstance(k, int) for k in nodes.keys())

def test_topological_sort(graph):
    """
    Test that the topologicalSort() method correctly sorts the nodes.

    Verifies that the topologicalSort() method correctly sorts the nodes in
    the graph. This is done by checking the result of the isTopologicallySorted()
    method before and after calling the topologicalSort() method.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    before = graph.isTopologicallySorted()
    graph.topologicalSort()
    after = graph.isTopologicallySorted()
    print(f"\n[blue] TEST {fn}:[/] [yellow]Topologically sorted before:[/] {before}, [yellow]after:[/] {after}")
    assert after is True

def test_has_soma_segment(graph):
    """
    Test that the hasSomaSegment() method correctly identifies neurons with a soma segment.

    Verifies that the hasSomaSegment() method correctly identifies neurons with a
    soma segment. This is done by calling the method on the test data neuron
    and verifying that it returns True.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    hasSoma = graph.hasSomaSegment()
    print(f"\n[blue] TEST {fn}:[/] has soma segment? {hasSoma}")
    assert hasSoma is True

def test_is_soma_missing(graph):
    """
    Test that the isSomaMissing() method correctly identifies neurons that are missing a soma.

    Verifies that the isSomaMissing() method correctly identifies neurons that
    are missing a soma. This is done by calling the method on the test data
    neuron and verifying that it returns False.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    print(f"\n[blue] TEST {fn}:[/] isSomaMissing? {graph.isSomaMissing()}")
    assert graph.isSomaMissing() is False

def test_remove_soma_segment(graph):
    """
    Test that the removeSomaSegment() method correctly removes the soma segment.

    Verifies that the removeSomaSegment() method correctly removes the soma
    segment from the neuron graph. This is done by calling the method on the
    test data neuron and verifying that the number of nodes decreases.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    before = graph.getNodes()
    after = graph.removeSomaSegment()
    print(f"\n[blue] TEST {fn}:[/] [yellow] Pre #nodes:[/] {len(before)}, [yellow] Post #nodes:[/] {len(after)}")
    assert len(after) < len(before)

def test_set_nodes(graph):
    """
    Test that the setNodes() method correctly replaces the nodes in the graph.

    Verifies that the setNodes() method correctly replaces the nodes in the
    graph. This is done by calling the method on the test data neuron and
    verifying that the number of nodes does not change.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    before = graph.getNodes()
    graph.setNodes(graph.getNodes())
    after = graph.getNodes()
    print(f"\n[blue] TEST {fn}:[/] [yellow] Pre #nodes:[/] {len(before)}, [yellow] Post #nodes:[/] {len(after)}")
    assert len(after)==len(before)

def test_preprocess(graph):
    """
    Test that the preprocess() method correctly reduces the number of nodes.

    Verifies that the preprocess() method correctly reduces the number of nodes
    in the neuron graph. This is done by calling the method on the test data
    neuron and verifying that the number of nodes decreases.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    before = graph.getNodes()
    after = graph.preprocess(before)
    print(f"\n[blue] TEST {fn}:[/] [yellow] Pre #nodes:[/] {len(before)}, [yellow] Post #nodes:[/] {len(after)}")
    assert len(after) < len(before)

def test_read_from_fileUGX(graph):
    """
    Test that the readFromFileUGX() method correctly reads neuron data from a UGX file.

    This test first loads neuron data from an SWC file and checks the number of nodes.
    Then, it creates a new NeuronGraph instance and reads neuron data from a UGX file.
    It verifies that the number of nodes in the new graph is equal to the number of nodes
    in the original graph, ensuring that the UGX file is read correctly.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    graph.readFromFile(get_test_data_path("neuron.swc"))
    before = graph.numberOfNodes()
    newgraph = ng.NeuronGraph()
    newgraph.readFromFileUGX(get_test_data_path("neuron.ugx"))
    after = newgraph.numberOfNodes()
    print(f"\n[blue] TEST {fn}:[/] [yellow] SWC:[/] {before}, [yellow] UGX:[/] {after}")
    assert after == before

def test_write_to_ugx(graph):
    """
    Test that the writeToFileUGX() method correctly writes neuron data to a UGX file.

    Verifies that the writeToFileUGX() method correctly writes neuron data to a
    UGX file. This is done by calling the method on the test data neuron,
    writing the neuron data to a UGX file, then reading the neuron data from
    the same UGX file. It verifies that the number of nodes in the new graph
    is equal to the number of nodes in the original graph, ensuring that the
    UGX file is written correctly.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    outfilename = get_output_dir()+"/test/writeUGX.ugx"
    graph.writeToFileUGX(outfilename)
    before = graph.numberOfNodes()
    graph.readFromFileUGX(outfilename)
    after = graph.numberOfNodes()
    print(f"\n[blue] TEST {fn}:[/] [yellow] WRT:[/] {before}, [yellow] READ:[/] {after}")
    assert after == before

def test_save_preprocess(graph):
    """
    Test that the preprocess() method correctly reduces the number of nodes and can write the resulting neuron data to an SWC file.

    Verifies that the preprocess() method correctly reduces the number of nodes
    in the neuron graph. This is done by calling the method on the test data
    neuron and verifying that the number of nodes decreases. The resulting
    neuron data is written to an SWC file.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    outfilename = get_output_dir()+"/test/preprocessSWC.swc"
    before = graph.getNodes()
    after = graph.preprocess(before)
    graph.writeToFile(after,outfilename)
    print(f"\n[blue] TEST {fn}:[/] [yellow] Pre:[/] {len(before)}, [yellow] Post:[/] {len(after)}")
    assert len(before) > len(after)

def test_splitedges(graph):
    """
    Test that the splitEdges() method correctly splits neuron edges once.

    Verifies that the splitEdges() method correctly splits neuron edges once.
    This is done by calling the method on the test data neuron, writing the
    resulting neuron data to an SWC file, and verifying that the number of
    nodes increases.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    outfilename = get_output_dir()+"/test/splitSWC.swc"
    before = graph.getNodes()
    after = graph.splitEdges()
    graph.writeToFile(after,outfilename)
    print(f"\n[blue] TEST {fn}:[/] [yellow] Pre:[/] {len(before)}, [yellow] Post:[/] {len(after)}")
    assert len(after) > len(before)

def test_splitedgesN(graph):
    """
    Test that the splitEdgesN() method correctly splits neuron edges multiple times.

    Verifies that the splitEdgesN() method correctly splits neuron edges multiple
    times. This is done by calling the method on the test data neuron N times,
    writing the resulting neuron data to a UGX file each time, and verifying that
    the number of nodes increases each time.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    before = graph.getNodes()
    N = 4
    afterset = graph.splitEdgesN(N)
    for i, after in enumerate(afterset):
        outfilename = get_output_dir()+"/test/splitSWC_"+str(i)+".ugx"
        graph.writeToFileUGX(after,outfilename)
        print(f"\n[blue] TEST {fn}:[/] [yellow] Pre:[/] {len(before)}, [yellow] Post:[/] {len(after)}")
        assert len(after) >= len(before)

def test_get_trunks(graph):
    """
    Test that the getTrunks() method returns a non-empty collection of trunks.

    Verifies that the getTrunks() method correctly extracts trunk segments from
    a neuron graph and that the number of trunks is greater than zero.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    trunks = graph.getTrunks(False)
    print(f"\n[blue] TEST {fn}:[/] [yellow] Num. Trunks:[/] {len(trunks)}")
    assert len(trunks) > 0

def test_assemble_trunks(graph):
    """
    Test that the assembleTrunks() method correctly reassembles a neuron graph
    from its trunks.

    This test first reads the number of nodes from the SWC file, then splits the
    nodes into trunks, reassembles the trunks back into a neuron graph using the
    assembleTrunks() method, and verifies that the two numbers are equal.
    """
    fn = inspect.currentframe().f_code.co_name
    trunks = graph.getTrunks(False)
    assembled = graph.assembleTrunks(trunks)
    print(f"\n[blue] TEST {fn}:[/] [yellow] #nodes:[/] {len(assembled)}")
    assert len(assembled) == graph.numberOfNodes()

    outfilename = get_output_dir()+"/test/reassembled1.swc"
    graph.writeToFile(assembled,outfilename)
    assert True

def test_assemble_trunks2(graph):
    """
    Test that the assembleTrunks() method correctly reassembles a neuron graph
    from its trunks when the trunks have been renumbered.

    This test first reads the number of nodes from the SWC file, then splits the
    nodes into trunks, renumbers the trunks to start at 1, reassembles the trunks
    back into a neuron graph using the assembleTrunks() method, and verifies
    that the two numbers are equal.

    Parameters
    ----------
    graph : NeuronGraph
        The neuron graph to test
    """
    fn = inspect.currentframe().f_code.co_name
    trunks = graph.getTrunks(False)
    trunkmap = graph.getTrunkParentMap(graph.getNodes(),trunks)
    trunks = graph.getTrunks(True)
    assembled = graph.assembleTrunks(trunks,trunkmap)
    print(f"\n[blue] TEST {fn}:[/] [yellow] #nodes:[/] {len(assembled)}")
    assert len(assembled) == graph.numberOfNodes()

    outfilename = get_output_dir()+"/test/reassembled2.swc"
    graph.writeToFile(assembled,outfilename)
    assert True

def test_assemble_linear_resample(graph):
    """
    Test that the assembleTrunks() method correctly reassembles a neuron graph
    from its linearly resampled trunks.

    This test first reads the number of nodes from the SWC file, then splits the
    nodes into trunks, linearly resamples the trunks, and assembles the trunks
    back into a neuron graph using the assembleTrunks() method. It then reads the
    number of nodes from the assembled graph and verifies that the two numbers
    are different, ensuring that the linear resampling changed the number of nodes
    in the graph.
    """
    fn = inspect.currentframe().f_code.co_name
    trunks = graph.getTrunks(False)
    trunkmap = graph.getTrunkParentMap(graph.getNodes(),trunks)
    resampled = graph.allLinearSplineResampledTrunks(trunks,delta)
    assembled = graph.assembleTrunks(resampled,trunkmap)
    print(f"\n[blue] TEST {fn}:[/] [yellow] #nodes:[/] {len(assembled)}")
    assert len(assembled) != graph.numberOfNodes()

    outfilename = get_output_dir()+"/test/reassembledlinear.swc"
    graph.writeToFile(assembled,outfilename)
    assert True

def test_assemble_cubic_resample(graph):
    """
    Test that the assembleTrunks() method correctly reassembles a neuron graph
    from its cubically resampled trunks.

    This test first retrieves the trunks from the neuron graph, then performs
    cubic spline resampling on the trunks. The resampled trunks are then
    reassembled into a neuron graph using the assembleTrunks() method. The test
    verifies that the number of nodes in the assembled graph is different from
    the original, indicating that the cubic resampling process changed the
    number of nodes in the graph.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    trunks = graph.getTrunks(False)
    trunkmap = graph.getTrunkParentMap(graph.getNodes(), trunks)
    resampled = graph.allCubicSplineResampledTrunks(trunks, delta)
    assembled = graph.assembleTrunks(resampled, trunkmap)
    print(f"\n[blue] TEST {fn}:[/] [yellow] #nodes:[/] {len(assembled)}")
    assert len(assembled) != graph.numberOfNodes()

    outfilename = get_output_dir() + "/test/reassembledcubic.swc"
    graph.writeToFile(assembled, outfilename)
    assert True

def test_swc_to_ugx(graph):
    """
    Test that the swc2ugx() method correctly converts a SWC file to a UGX file.

    This test first reads the number of nodes from the SWC file, then converts the SWC
    file to a UGX file using the swc2ugx() method. It then reads the number of nodes
    from the UGX file and verifies that the two numbers are equal, ensuring that the
    UGX file is correctly converted from the SWC file.
    """
    fn = inspect.currentframe().f_code.co_name
    infile= get_test_data_path("neuron.swc")
    outfile = get_output_dir()+"/test/swc2ugx.ugx"
    graph.swc2ugx(infile,outfile)
    before = graph.numberOfNodes()
    graph.readFromFileUGX(outfile)
    after = graph.numberOfNodes()
    print(f"\n[blue] TEST {fn}:[/] [yellow] SWC:[/] {before}, [yellow] UGX:[/] {after}")
    assert after == before

def test_ugx_to_swc(graph):
    """
    Test that the ugx2swc() method correctly reads neuron data from a UGX file.

    This test first reads neuron data from a UGX file and checks the number of nodes.
    Then, it creates a new NeuronGraph instance and reads neuron data from the same UGX
    file. It verifies that the number of nodes in the new graph is equal to the number
    of nodes in the original graph, ensuring that the UGX file is read correctly.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    infile= get_test_data_path("neuron.ugx")
    outfile = get_output_dir()+"/test/ugx2swc.swc"
    graph.ugx2swc(infile,outfile)
    before = graph.numberOfNodes()
    graph.readFromFile(outfile)
    after = graph.numberOfNodes()
    print(f"\n[blue] TEST {fn}:[/] [yellow] UGX:[/] {before}, [yellow] SWC:[/] {after}")
    assert after == before

def test_generate_refinements_cubic(graph):
    """
    Test that the generateRefinements() method correctly generates cubic refinements.

    Verifies that the generateRefinements() method produces the expected number of
    refinements using cubic interpolation. This is done by checking that each refined
    node set has at least as many nodes as the original set.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    delta,N,method = 12.0,6,"cubic"
    before = graph.getNodes()
    refinements = graph.generateRefinements(before,delta,N,method)
    for _,after in refinements.items():
        print(f"\n[blue] TEST {fn}:[/] [yellow] before:[/] {len(before)}, [yellow] after:[/] {len(after)}")
        assert len(after) >= len(before)

def test_generate_refinements_linear(graph):
    """
    Test that the generateRefinements() method correctly generates linear refinements.

    Verifies that the generateRefinements() method produces the expected number of
    refinements using linear interpolation. This is done by checking that each refined
    node set has at least as many nodes as the original set.

    Args:
        graph: A fixture providing a neuron graph object.
    """
    fn = inspect.currentframe().f_code.co_name
    delta, N, method = 12.0, 6, "linear"
    before = graph.getNodes()
    refinements = graph.generateRefinements(before, delta, N, method)
    for _, after in refinements.items():
        print(f"\n[blue] TEST {fn}:[/] [yellow] before:[/] {len(before)}, [yellow] after:[/] {len(after)}")
        assert len(after) >= len(before)