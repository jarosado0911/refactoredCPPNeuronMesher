<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>refactoredCPPNeuronMesher: NeuronGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">refactoredCPPNeuronMesher
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classNeuronGraph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classNeuronGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NeuronGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for representing and processing neuron morphology graphs.  
 <a href="classNeuronGraph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="neurongraph_8h_source.html">neurongraph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad652dbc8d74bbd8f0d5dc182711a4d6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#ad652dbc8d74bbd8f0d5dc182711a4d6f">NeuronGraph</a> ()</td></tr>
<tr class="memdesc:ad652dbc8d74bbd8f0d5dc182711a4d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classNeuronGraph.html#ad652dbc8d74bbd8f0d5dc182711a4d6f">More...</a><br /></td></tr>
<tr class="separator:ad652dbc8d74bbd8f0d5dc182711a4d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2d5d03d0953e5cff1edc4e396d97c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a8b2d5d03d0953e5cff1edc4e396d97c2">NeuronGraph</a> (std::string filename)</td></tr>
<tr class="memdesc:a8b2d5d03d0953e5cff1edc4e396d97c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that loads a neuron from file.  <a href="classNeuronGraph.html#a8b2d5d03d0953e5cff1edc4e396d97c2">More...</a><br /></td></tr>
<tr class="separator:a8b2d5d03d0953e5cff1edc4e396d97c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76872c37616f9517420fd8ef11240040"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a76872c37616f9517420fd8ef11240040">NeuronGraph</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet)</td></tr>
<tr class="memdesc:a76872c37616f9517420fd8ef11240040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classNeuronGraph.html" title="Class for representing and processing neuron morphology graphs.">NeuronGraph</a> from an existing set of nodes.  <a href="classNeuronGraph.html#a76872c37616f9517420fd8ef11240040">More...</a><br /></td></tr>
<tr class="separator:a76872c37616f9517420fd8ef11240040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453e31c723b0dc9d692d8663d93be51a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a453e31c723b0dc9d692d8663d93be51a">addNode</a> (const <a class="el" href="structSWCNode.html">SWCNode</a> &amp;node)</td></tr>
<tr class="memdesc:a453e31c723b0dc9d692d8663d93be51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a single node to the graph.  <a href="classNeuronGraph.html#a453e31c723b0dc9d692d8663d93be51a">More...</a><br /></td></tr>
<tr class="separator:a453e31c723b0dc9d692d8663d93be51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbcfc32da26b3bc0fe7211ee0b08237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a4fbcfc32da26b3bc0fe7211ee0b08237">setNodes</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet)</td></tr>
<tr class="memdesc:a4fbcfc32da26b3bc0fe7211ee0b08237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the current set of nodes in the graph.  <a href="classNeuronGraph.html#a4fbcfc32da26b3bc0fe7211ee0b08237">More...</a><br /></td></tr>
<tr class="separator:a4fbcfc32da26b3bc0fe7211ee0b08237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7eae0aeccf7e7aec8f3cab6008f37c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a7b7eae0aeccf7e7aec8f3cab6008f37c">isTopologicallySorted</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet) const</td></tr>
<tr class="memdesc:a7b7eae0aeccf7e7aec8f3cab6008f37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a set of nodes is topologically sorted.  <a href="classNeuronGraph.html#a7b7eae0aeccf7e7aec8f3cab6008f37c">More...</a><br /></td></tr>
<tr class="separator:a7b7eae0aeccf7e7aec8f3cab6008f37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a94b95b0afc5d98590e631f963a970d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a0a94b95b0afc5d98590e631f963a970d">isTopologicallySorted</a> () const</td></tr>
<tr class="separator:a0a94b95b0afc5d98590e631f963a970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66e25466d6c0b228b95c118963e7cb0"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#ab66e25466d6c0b228b95c118963e7cb0">topologicalSort</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet) const</td></tr>
<tr class="memdesc:ab66e25466d6c0b228b95c118963e7cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts nodes topologically using Kahn's algorithm.  <a href="classNeuronGraph.html#ab66e25466d6c0b228b95c118963e7cb0">More...</a><br /></td></tr>
<tr class="separator:ab66e25466d6c0b228b95c118963e7cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096f5d8b9231d0b27f0a60a694db41d3"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a096f5d8b9231d0b27f0a60a694db41d3">topologicalSort</a> () const</td></tr>
<tr class="separator:a096f5d8b9231d0b27f0a60a694db41d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc081d9ef1972cbc262571246698f0f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#abc081d9ef1972cbc262571246698f0f2">hasSomaSegment</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet) const</td></tr>
<tr class="memdesc:abc081d9ef1972cbc262571246698f0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the node set contains a soma segment.  <a href="classNeuronGraph.html#abc081d9ef1972cbc262571246698f0f2">More...</a><br /></td></tr>
<tr class="separator:abc081d9ef1972cbc262571246698f0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade30f063c2aeaaa9817606497f16875b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#ade30f063c2aeaaa9817606497f16875b">hasSomaSegment</a> () const</td></tr>
<tr class="separator:ade30f063c2aeaaa9817606497f16875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a4ee923b6547a3d2fa7c8953932ed0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a84a4ee923b6547a3d2fa7c8953932ed0">isSomaMissing</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet) const</td></tr>
<tr class="memdesc:a84a4ee923b6547a3d2fa7c8953932ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the node set is missing a soma.  <a href="classNeuronGraph.html#a84a4ee923b6547a3d2fa7c8953932ed0">More...</a><br /></td></tr>
<tr class="separator:a84a4ee923b6547a3d2fa7c8953932ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25c92d56c3019385447d3dc7ab86346"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#ae25c92d56c3019385447d3dc7ab86346">isSomaMissing</a> () const</td></tr>
<tr class="separator:ae25c92d56c3019385447d3dc7ab86346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5eb4290d85b7a134f95fa5b453ba50"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#aed5eb4290d85b7a134f95fa5b453ba50">removeSomaSegment</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;inputNodes) const</td></tr>
<tr class="memdesc:aed5eb4290d85b7a134f95fa5b453ba50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the soma segment from a set of nodes.  <a href="classNeuronGraph.html#aed5eb4290d85b7a134f95fa5b453ba50">More...</a><br /></td></tr>
<tr class="separator:aed5eb4290d85b7a134f95fa5b453ba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0ce27089a76553f8e4e109ffdf8183"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a0d0ce27089a76553f8e4e109ffdf8183">removeSomaSegment</a> () const</td></tr>
<tr class="separator:a0d0ce27089a76553f8e4e109ffdf8183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da98a459bd4ddaa00df5ed08bc80477"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a4da98a459bd4ddaa00df5ed08bc80477">setSoma</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet) const</td></tr>
<tr class="memdesc:a4da98a459bd4ddaa00df5ed08bc80477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a soma node if none exists.  <a href="classNeuronGraph.html#a4da98a459bd4ddaa00df5ed08bc80477">More...</a><br /></td></tr>
<tr class="separator:a4da98a459bd4ddaa00df5ed08bc80477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0c1b97c8866106d3bb7f803b94f6f4"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a6b0c1b97c8866106d3bb7f803b94f6f4">setSoma</a> () const</td></tr>
<tr class="separator:a6b0c1b97c8866106d3bb7f803b94f6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d21c08d8a35dd270a0aa8032c4fe35"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a48d21c08d8a35dd270a0aa8032c4fe35">preprocess</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet) const</td></tr>
<tr class="memdesc:a48d21c08d8a35dd270a0aa8032c4fe35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies standard preprocessing steps to a set of nodes.  <a href="classNeuronGraph.html#a48d21c08d8a35dd270a0aa8032c4fe35">More...</a><br /></td></tr>
<tr class="separator:a48d21c08d8a35dd270a0aa8032c4fe35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee6517767cd316da4474cb55c67307f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a8ee6517767cd316da4474cb55c67307f">readFromFile</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a8ee6517767cd316da4474cb55c67307f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads neuron data from an SWC file.  <a href="classNeuronGraph.html#a8ee6517767cd316da4474cb55c67307f">More...</a><br /></td></tr>
<tr class="separator:a8ee6517767cd316da4474cb55c67307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1a573b34c20a37ec3ca5bdf530bdcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a4b1a573b34c20a37ec3ca5bdf530bdcb">writeToFile</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a4b1a573b34c20a37ec3ca5bdf530bdcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a set of nodes to an SWC file.  <a href="classNeuronGraph.html#a4b1a573b34c20a37ec3ca5bdf530bdcb">More...</a><br /></td></tr>
<tr class="separator:a4b1a573b34c20a37ec3ca5bdf530bdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dec1b5ec2012af3aa6cb50ce2c08941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a0dec1b5ec2012af3aa6cb50ce2c08941">writeToFile</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a0dec1b5ec2012af3aa6cb50ce2c08941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8742e842a6ce2eb1981d36ba9a8317fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a8742e842a6ce2eb1981d36ba9a8317fb">readFromFileUGX</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a8742e842a6ce2eb1981d36ba9a8317fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads neuron data from a UGX file.  <a href="classNeuronGraph.html#a8742e842a6ce2eb1981d36ba9a8317fb">More...</a><br /></td></tr>
<tr class="separator:a8742e842a6ce2eb1981d36ba9a8317fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8deb90cf431df071765a400ddb144c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a1c8deb90cf431df071765a400ddb144c">readFromFileUGXorSWC</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a1c8deb90cf431df071765a400ddb144c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a neuron file, automatically detecting the format.  <a href="classNeuronGraph.html#a1c8deb90cf431df071765a400ddb144c">More...</a><br /></td></tr>
<tr class="separator:a1c8deb90cf431df071765a400ddb144c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938d33cc1ee5a5abc291c555e0a60ad5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a938d33cc1ee5a5abc291c555e0a60ad5">writeToFileUGX</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a938d33cc1ee5a5abc291c555e0a60ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a set of nodes to a UGX file.  <a href="classNeuronGraph.html#a938d33cc1ee5a5abc291c555e0a60ad5">More...</a><br /></td></tr>
<tr class="separator:a938d33cc1ee5a5abc291c555e0a60ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4db233a8438b8eb45241f79c3a8cfe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#aa4db233a8438b8eb45241f79c3a8cfe4">writeToFileUGX</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:aa4db233a8438b8eb45241f79c3a8cfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedde45f3cf0e5a3bb8cec88b864580a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#aedde45f3cf0e5a3bb8cec88b864580a6">swc2ugx</a> (const std::string &amp;inputfile, const std::string &amp;outputfile)</td></tr>
<tr class="memdesc:aedde45f3cf0e5a3bb8cec88b864580a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an SWC file to UGX format.  <a href="classNeuronGraph.html#aedde45f3cf0e5a3bb8cec88b864580a6">More...</a><br /></td></tr>
<tr class="separator:aedde45f3cf0e5a3bb8cec88b864580a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ec77a2f3c9e69317c30366560761f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a31ec77a2f3c9e69317c30366560761f5">ugx2swc</a> (const std::string &amp;inputfile, const std::string &amp;outputfile)</td></tr>
<tr class="memdesc:a31ec77a2f3c9e69317c30366560761f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a UGX file to SWC format.  <a href="classNeuronGraph.html#a31ec77a2f3c9e69317c30366560761f5">More...</a><br /></td></tr>
<tr class="separator:a31ec77a2f3c9e69317c30366560761f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95079dcc37ed05aae8680eacf1fad317"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a95079dcc37ed05aae8680eacf1fad317">numberOfNodes</a> ()</td></tr>
<tr class="memdesc:a95079dcc37ed05aae8680eacf1fad317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in the graph.  <a href="classNeuronGraph.html#a95079dcc37ed05aae8680eacf1fad317">More...</a><br /></td></tr>
<tr class="separator:a95079dcc37ed05aae8680eacf1fad317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d477e87f08f5d83df1e22b3e2f31ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#ad7d477e87f08f5d83df1e22b3e2f31ef">numberOfEdges</a> ()</td></tr>
<tr class="memdesc:ad7d477e87f08f5d83df1e22b3e2f31ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges in the graph.  <a href="classNeuronGraph.html#ad7d477e87f08f5d83df1e22b3e2f31ef">More...</a><br /></td></tr>
<tr class="separator:ad7d477e87f08f5d83df1e22b3e2f31ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf6c2dcb7cd1aa1d3664009eede14be"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#aadf6c2dcb7cd1aa1d3664009eede14be">getNodes</a> ()</td></tr>
<tr class="memdesc:aadf6c2dcb7cd1aa1d3664009eede14be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of all nodes in the graph.  <a href="classNeuronGraph.html#aadf6c2dcb7cd1aa1d3664009eede14be">More...</a><br /></td></tr>
<tr class="separator:aadf6c2dcb7cd1aa1d3664009eede14be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd02c37f81fc7d5cfbb929bd25e1fa2"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a4dd02c37f81fc7d5cfbb929bd25e1fa2">splitEdges</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet) const</td></tr>
<tr class="memdesc:a4dd02c37f81fc7d5cfbb929bd25e1fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits all edges in the graph by inserting midpoint nodes.  <a href="classNeuronGraph.html#a4dd02c37f81fc7d5cfbb929bd25e1fa2">More...</a><br /></td></tr>
<tr class="separator:a4dd02c37f81fc7d5cfbb929bd25e1fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff93693953850f3bbda6dd5e694de08"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#abff93693953850f3bbda6dd5e694de08">splitEdges</a> () const</td></tr>
<tr class="separator:abff93693953850f3bbda6dd5e694de08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde3c34e7d73fd00635d4fef5a9fcb3d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#acde3c34e7d73fd00635d4fef5a9fcb3d">splitEdgesN</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet, int N) const</td></tr>
<tr class="memdesc:acde3c34e7d73fd00635d4fef5a9fcb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies edge splitting N times recursively.  <a href="classNeuronGraph.html#acde3c34e7d73fd00635d4fef5a9fcb3d">More...</a><br /></td></tr>
<tr class="separator:acde3c34e7d73fd00635d4fef5a9fcb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aeb1a2193d8a712338836d5c9ce53f4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a5aeb1a2193d8a712338836d5c9ce53f4">splitEdgesN</a> (int N) const</td></tr>
<tr class="separator:a5aeb1a2193d8a712338836d5c9ce53f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae750a60642aa3d1a30ec9265795cd065"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#ae750a60642aa3d1a30ec9265795cd065">getTrunks</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet, bool resetIndex=false) const</td></tr>
<tr class="memdesc:ae750a60642aa3d1a30ec9265795cd065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts trunk segments from a neuron morphology.  <a href="classNeuronGraph.html#ae750a60642aa3d1a30ec9265795cd065">More...</a><br /></td></tr>
<tr class="separator:ae750a60642aa3d1a30ec9265795cd065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bfbcdde59807456a3ed21aa244fe48"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a74bfbcdde59807456a3ed21aa244fe48">getTrunks</a> (bool resetIndex=false) const</td></tr>
<tr class="separator:a74bfbcdde59807456a3ed21aa244fe48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a2201e3e2eddb93176ce3e84bfc619"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#aa4a2201e3e2eddb93176ce3e84bfc619">getTrunkParentMap</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet, const std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&gt; &amp;trunkNodeSets) const</td></tr>
<tr class="memdesc:aa4a2201e3e2eddb93176ce3e84bfc619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mapping from trunk IDs to their parent trunk IDs.  <a href="classNeuronGraph.html#aa4a2201e3e2eddb93176ce3e84bfc619">More...</a><br /></td></tr>
<tr class="separator:aa4a2201e3e2eddb93176ce3e84bfc619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7961eded24b6524392b01fdfa7e98452"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a7961eded24b6524392b01fdfa7e98452">assembleTrunks</a> (const std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&gt; &amp;trunkNodeSets) const</td></tr>
<tr class="memdesc:a7961eded24b6524392b01fdfa7e98452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines multiple trunks into a single node set.  <a href="classNeuronGraph.html#a7961eded24b6524392b01fdfa7e98452">More...</a><br /></td></tr>
<tr class="separator:a7961eded24b6524392b01fdfa7e98452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8067ed0a71ebcbfd9092d25aec536545"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a8067ed0a71ebcbfd9092d25aec536545">assembleTrunks</a> (const std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&gt; &amp;resampledTrunks, const std::map&lt; int, int &gt; &amp;trunkParentMap)</td></tr>
<tr class="memdesc:a8067ed0a71ebcbfd9092d25aec536545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines resampled trunks using a parent-child relationship map.  <a href="classNeuronGraph.html#a8067ed0a71ebcbfd9092d25aec536545">More...</a><br /></td></tr>
<tr class="separator:a8067ed0a71ebcbfd9092d25aec536545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4263b75e5c5c97d6f65dd681dbdfff60"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a4263b75e5c5c97d6f65dd681dbdfff60">linearSplineResampleTrunk</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;trunk, double &amp;delta) const</td></tr>
<tr class="memdesc:a4263b75e5c5c97d6f65dd681dbdfff60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resamples a single trunk using linear interpolation.  <a href="classNeuronGraph.html#a4263b75e5c5c97d6f65dd681dbdfff60">More...</a><br /></td></tr>
<tr class="separator:a4263b75e5c5c97d6f65dd681dbdfff60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126fba2e060c47a5a20445af0622d06b"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a126fba2e060c47a5a20445af0622d06b">allLinearSplineResampledTrunks</a> (std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&gt; &amp;trunks, double &amp;delta) const</td></tr>
<tr class="memdesc:a126fba2e060c47a5a20445af0622d06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resamples all trunks using linear interpolation.  <a href="classNeuronGraph.html#a126fba2e060c47a5a20445af0622d06b">More...</a><br /></td></tr>
<tr class="separator:a126fba2e060c47a5a20445af0622d06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a90fcdd47904cee5fc06b451e2d956"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#ae4a90fcdd47904cee5fc06b451e2d956">cubicSplineResampleTrunk</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;trunk, double &amp;delta) const</td></tr>
<tr class="memdesc:ae4a90fcdd47904cee5fc06b451e2d956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resamples a single trunk using cubic spline interpolation.  <a href="classNeuronGraph.html#ae4a90fcdd47904cee5fc06b451e2d956">More...</a><br /></td></tr>
<tr class="separator:ae4a90fcdd47904cee5fc06b451e2d956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198959fac3c6691530c888896ae777ae"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a198959fac3c6691530c888896ae777ae">allCubicSplineResampledTrunks</a> (std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&gt; &amp;trunks, double &amp;delta) const</td></tr>
<tr class="memdesc:a198959fac3c6691530c888896ae777ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resamples all trunks using cubic spline interpolation.  <a href="classNeuronGraph.html#a198959fac3c6691530c888896ae777ae">More...</a><br /></td></tr>
<tr class="separator:a198959fac3c6691530c888896ae777ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf58bd7db5d97c97ec95b63c679a62a"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#acbf58bd7db5d97c97ec95b63c679a62a">generateRefinements</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet, double &amp;delta, int &amp;N, std::string &amp;method)</td></tr>
<tr class="memdesc:acbf58bd7db5d97c97ec95b63c679a62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates multiple levels of refined neuron morphologies.  <a href="classNeuronGraph.html#acbf58bd7db5d97c97ec95b63c679a62a">More...</a><br /></td></tr>
<tr class="separator:acbf58bd7db5d97c97ec95b63c679a62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607cb1a4a78a63ac33c462337f178b18"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a607cb1a4a78a63ac33c462337f178b18">generateRefinements</a> (double &amp;delta, int &amp;N, std::string &amp;method)</td></tr>
<tr class="separator:a607cb1a4a78a63ac33c462337f178b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a76f4e1ec5197389c1c073a2c891a4e2e"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a76f4e1ec5197389c1c073a2c891a4e2e">getNeighborMap</a> (const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;nodeSet) const</td></tr>
<tr class="memdesc:a76f4e1ec5197389c1c073a2c891a4e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a neighbor map from a set of nodes.  <a href="classNeuronGraph.html#a76f4e1ec5197389c1c073a2c891a4e2e">More...</a><br /></td></tr>
<tr class="separator:a76f4e1ec5197389c1c073a2c891a4e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a312adb405dceafb6b1a736bd8e4ded88"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#a312adb405dceafb6b1a736bd8e4ded88">nodes</a></td></tr>
<tr class="memdesc:a312adb405dceafb6b1a736bd8e4ded88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of node IDs to <a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> objects.  <a href="classNeuronGraph.html#a312adb405dceafb6b1a736bd8e4ded88">More...</a><br /></td></tr>
<tr class="separator:a312adb405dceafb6b1a736bd8e4ded88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cbc0c7feb5dcfbc415fb65ca5f782a"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuronGraph.html#ae9cbc0c7feb5dcfbc415fb65ca5f782a">edges</a></td></tr>
<tr class="memdesc:ae9cbc0c7feb5dcfbc415fb65ca5f782a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjacency list representation of the neuron graph.  <a href="classNeuronGraph.html#ae9cbc0c7feb5dcfbc415fb65ca5f782a">More...</a><br /></td></tr>
<tr class="separator:ae9cbc0c7feb5dcfbc415fb65ca5f782a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for representing and processing neuron morphology graphs. </p>
<p>The <a class="el" href="classNeuronGraph.html" title="Class for representing and processing neuron morphology graphs.">NeuronGraph</a> class provides comprehensive functionality for working with neuron morphology data, including file I/O, topological analysis, and geometric processing. It supports both SWC and UGX file formats and includes methods for manipulating and analyzing neuron structures.</p>
<p>Key features:</p><ul>
<li>Reading and writing SWC/UGX files</li>
<li>Topological sorting and validation</li>
<li>Soma detection and processing</li>
<li>Edge splitting and resampling</li>
<li>Trunk extraction and manipulation </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad652dbc8d74bbd8f0d5dc182711a4d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad652dbc8d74bbd8f0d5dc182711a4d6f">&#9670;&nbsp;</a></span>NeuronGraph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NeuronGraph::NeuronGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty <a class="el" href="classNeuronGraph.html" title="Class for representing and processing neuron morphology graphs.">NeuronGraph</a> with no nodes or edges. </p>

</div>
</div>
<a id="a8b2d5d03d0953e5cff1edc4e396d97c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2d5d03d0953e5cff1edc4e396d97c2">&#9670;&nbsp;</a></span>NeuronGraph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NeuronGraph::NeuronGraph </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that loads a neuron from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to the SWC or UGX file to load</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a1c8deb90cf431df071765a400ddb144c" title="Reads a neuron file, automatically detecting the format.">readFromFileUGXorSWC()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a8b2d5d03d0953e5cff1edc4e396d97c2_cgraph.png" border="0" usemap="#aclassNeuronGraph_a8b2d5d03d0953e5cff1edc4e396d97c2_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a8b2d5d03d0953e5cff1edc4e396d97c2_cgraph" id="aclassNeuronGraph_a8b2d5d03d0953e5cff1edc4e396d97c2_cgraph">
<area shape="rect" title="Constructor that loads a neuron from file." alt="" coords="5,13,189,39"/>
<area shape="rect" href="classNeuronGraph.html#a1c8deb90cf431df071765a400ddb144c" title="Reads a neuron file, automatically detecting the format." alt="" coords="237,5,420,47"/>
</map>
</div>

</div>
</div>
<a id="a76872c37616f9517420fd8ef11240040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76872c37616f9517420fd8ef11240040">&#9670;&nbsp;</a></span>NeuronGraph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NeuronGraph::NeuronGraph </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classNeuronGraph.html" title="Class for representing and processing neuron morphology graphs.">NeuronGraph</a> from an existing set of nodes. </p>
<p>Constructor that initializes a <a class="el" href="classNeuronGraph.html" title="Class for representing and processing neuron morphology graphs.">NeuronGraph</a> from a set of SWC nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>Map of node IDs to <a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> objects</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeSet</td><td>A map containing SWC nodes indexed by their IDs</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates a new <a class="el" href="classNeuronGraph.html" title="Class for representing and processing neuron morphology graphs.">NeuronGraph</a> instance by clearing any existing data and populating the graph with the provided nodes. It automatically builds the parent-child relationships between nodes.</p>
<dl class="section note"><dt>Note</dt><dd>The nodeSet parameter uses structured binding, so the key is ignored (_) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a453e31c723b0dc9d692d8663d93be51a" title="Adds a single node to the graph.">addNode(const SWCNode&amp; node)</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a453e31c723b0dc9d692d8663d93be51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453e31c723b0dc9d692d8663d93be51a">&#9670;&nbsp;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NeuronGraph::addNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSWCNode.html">SWCNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a single node to the graph. </p>
<p>Adds a single node to the graph and updates edge relationships.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The <a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is typically used internally by other methods that read or generate node data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The <a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> to be added to the graph</td></tr>
  </table>
  </dd>
</dl>
<p>This method adds a node to the internal nodes map and automatically creates the parent-child edge relationship if the node has a valid parent (pid != -1). Root nodes (pid == -1) are added without creating edges.</p>
<dl class="section note"><dt>Note</dt><dd>This method assumes node IDs are unique and will overwrite existing nodes </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> structure for node data format </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a453e31c723b0dc9d692d8663d93be51a_icgraph.png" border="0" usemap="#aclassNeuronGraph_a453e31c723b0dc9d692d8663d93be51a_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a453e31c723b0dc9d692d8663d93be51a_icgraph" id="aclassNeuronGraph_a453e31c723b0dc9d692d8663d93be51a_icgraph">
<area shape="rect" title="Adds a single node to the graph." alt="" coords="204,5,363,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,5,156,32"/>
</map>
</div>

</div>
</div>
<a id="a198959fac3c6691530c888896ae777ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198959fac3c6691530c888896ae777ae">&#9670;&nbsp;</a></span>allCubicSplineResampledTrunks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt; NeuronGraph::allCubicSplineResampledTrunks </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>trunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resamples all trunks using cubic spline interpolation. </p>
<p>Applies cubic spline resampling to all trunk segments in a neuron morphology.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trunks</td><td>Map of trunk IDs to their nodes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">delta</td><td>Target spacing between resampled points (may be adjusted) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new map of resampled trunks</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunks</td><td>Map of trunk segments where each key is a trunk ID and value is a map of node IDs to SWCNodes </td></tr>
    <tr><td class="paramname">delta</td><td>Target distance between consecutive nodes in the resampled trunks (in microns) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;int, std::map&lt;int, SWCNode&gt;&gt; Map of resampled trunks with the same structure as input</dd></dl>
<p>This method processes each trunk segment in the input map and applies cubic spline resampling to achieve a smooth and uniform node distribution. The resampling is performed independently on each trunk.</p>
<p>Key features:</p><ul>
<li>Fits a smooth cubic spline through the original nodes of each trunk</li>
<li>Samples points at approximately 'delta' intervals along the spline</li>
<li>Preserves the start and end points of each trunk exactly</li>
<li>Maintains the original topology while improving smoothness</li>
<li>Handles each trunk segment independently</li>
</ul>
<p>The resampling process involves:</p><ol type="1">
<li>Fitting natural cubic splines to the x, y, and z coordinates separately</li>
<li>Parameterizing the spline by arc length</li>
<li>Sampling new points at approximately 'delta' intervals along the curve</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>This method produces smoother results than linear interpolation but is more computationally intensive </dd>
<dd>
The actual spacing may vary slightly to ensure the curve is sampled properly </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#ae4a90fcdd47904cee5fc06b451e2d956" title="Resamples a single trunk using cubic spline interpolation.">cubicSplineResampleTrunk()</a> for the single-trunk implementation </dd>
<dd>
<a class="el" href="classNeuronGraph.html#a126fba2e060c47a5a20445af0622d06b" title="Resamples all trunks using linear interpolation.">allLinearSplineResampledTrunks()</a> for a faster but less smooth alternative </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a198959fac3c6691530c888896ae777ae_cgraph.png" border="0" usemap="#aclassNeuronGraph_a198959fac3c6691530c888896ae777ae_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a198959fac3c6691530c888896ae777ae_cgraph" id="aclassNeuronGraph_a198959fac3c6691530c888896ae777ae_cgraph">
<area shape="rect" title="Resamples all trunks using cubic spline interpolation." alt="" coords="5,5,196,47"/>
<area shape="rect" href="classNeuronGraph.html#ae4a90fcdd47904cee5fc06b451e2d956" title="Resamples a single trunk using cubic spline interpolation." alt="" coords="244,5,419,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a198959fac3c6691530c888896ae777ae_icgraph.png" border="0" usemap="#aclassNeuronGraph_a198959fac3c6691530c888896ae777ae_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a198959fac3c6691530c888896ae777ae_icgraph" id="aclassNeuronGraph_a198959fac3c6691530c888896ae777ae_icgraph">
<area shape="rect" title="Resamples all trunks using cubic spline interpolation." alt="" coords="563,49,753,90"/>
<area shape="rect" href="classNeuronGraph.html#acbf58bd7db5d97c97ec95b63c679a62a" title="Generates multiple levels of refined neuron morphologies." alt="" coords="284,5,515,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="45,56,196,83"/>
<area shape="rect" href="callbacks_8cpp.html#a0b9e239c8889734711f29fe45551605b" title="Handles keyboard input events for the neuron viewer." alt="" coords="352,107,447,133"/>
<area shape="rect" href="classNeuronGraph.html#a607cb1a4a78a63ac33c462337f178b18" title=" " alt="" coords="5,5,236,32"/>
<area shape="rect" href="neuronviewer_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title=" " alt="" coords="95,107,146,133"/>
</map>
</div>

</div>
</div>
<a id="a126fba2e060c47a5a20445af0622d06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126fba2e060c47a5a20445af0622d06b">&#9670;&nbsp;</a></span>allLinearSplineResampledTrunks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt; NeuronGraph::allLinearSplineResampledTrunks </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>trunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resamples all trunks using linear interpolation. </p>
<p>Applies linear spline resampling to all trunk segments in a neuron morphology.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trunks</td><td>Map of trunk IDs to their nodes </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">delta</td><td>Target spacing between resampled points (may be adjusted) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new map of resampled trunks</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunks</td><td>Map of trunk segments where each key is a trunk ID and value is a map of node IDs to SWCNodes </td></tr>
    <tr><td class="paramname">delta</td><td>Target distance between consecutive nodes in the resampled trunks (in microns) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;int, std::map&lt;int, SWCNode&gt;&gt; Map of resampled trunks with the same structure as input</dd></dl>
<p>This method processes each trunk segment in the input map and applies linear spline resampling to achieve a more uniform node distribution. The resampling is performed independently on each trunk.</p>
<p>Key features:</p><ul>
<li>Preserves the start and end points of each trunk exactly</li>
<li>Inserts new nodes to achieve approximately 'delta' spacing between points</li>
<li>Maintains the original topology and branching structure</li>
<li>Handles each trunk segment independently</li>
</ul>
<p>The resampling process involves:</p><ol type="1">
<li>Calculating the total length of each trunk</li>
<li>Determining the number of segments needed based on 'delta'</li>
<li>Linearly interpolating new points along each segment</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The actual spacing may vary slightly to ensure the start and end points are preserved exactly </dd>
<dd>
This method is typically used as a preprocessing step before mesh generation </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a4263b75e5c5c97d6f65dd681dbdfff60" title="Resamples a single trunk using linear interpolation.">linearSplineResampleTrunk()</a> for the single-trunk implementation </dd>
<dd>
<a class="el" href="classNeuronGraph.html#a198959fac3c6691530c888896ae777ae" title="Resamples all trunks using cubic spline interpolation.">allCubicSplineResampledTrunks()</a> for a smoother but more computationally intensive alternative </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a126fba2e060c47a5a20445af0622d06b_cgraph.png" border="0" usemap="#aclassNeuronGraph_a126fba2e060c47a5a20445af0622d06b_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a126fba2e060c47a5a20445af0622d06b_cgraph" id="aclassNeuronGraph_a126fba2e060c47a5a20445af0622d06b_cgraph">
<area shape="rect" title="Resamples all trunks using linear interpolation." alt="" coords="5,5,196,47"/>
<area shape="rect" href="classNeuronGraph.html#a4263b75e5c5c97d6f65dd681dbdfff60" title="Resamples a single trunk using linear interpolation." alt="" coords="244,5,419,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a126fba2e060c47a5a20445af0622d06b_icgraph.png" border="0" usemap="#aclassNeuronGraph_a126fba2e060c47a5a20445af0622d06b_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a126fba2e060c47a5a20445af0622d06b_icgraph" id="aclassNeuronGraph_a126fba2e060c47a5a20445af0622d06b_icgraph">
<area shape="rect" title="Resamples all trunks using linear interpolation." alt="" coords="563,23,753,65"/>
<area shape="rect" href="classNeuronGraph.html#acbf58bd7db5d97c97ec95b63c679a62a" title="Generates multiple levels of refined neuron morphologies." alt="" coords="284,5,515,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="45,56,196,83"/>
<area shape="rect" href="classNeuronGraph.html#a607cb1a4a78a63ac33c462337f178b18" title=" " alt="" coords="5,5,236,32"/>
</map>
</div>

</div>
</div>
<a id="a8067ed0a71ebcbfd9092d25aec536545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8067ed0a71ebcbfd9092d25aec536545">&#9670;&nbsp;</a></span>assembleTrunks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; NeuronGraph::assembleTrunks </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>resampledTrunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>trunkParentMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines resampled trunks using a parent-child relationship map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">resampledTrunks</td><td>Map of trunk IDs to their resampled nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trunkParentMap</td><td>Map of trunk IDs to their parent trunk IDs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single map containing all nodes from all trunks with updated parent references</dd></dl>
<p>This version is used when trunk nodes have been resampled and need to be reconnected based on the original topology. </p>

</div>
</div>
<a id="a7961eded24b6524392b01fdfa7e98452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7961eded24b6524392b01fdfa7e98452">&#9670;&nbsp;</a></span>assembleTrunks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; NeuronGraph::assembleTrunks </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>trunkNodeSets</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines multiple trunks into a single node set. </p>
<p>Combines multiple trunk segments into a single neuron representation with sequential node IDs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trunkNodeSets</td><td>Map of trunk IDs to their nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single map containing all nodes from all trunks</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version preserves the original node IDs</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunkNodeSets</td><td>Map of trunk segments where each key is a trunk ID and value is a map of node IDs to SWCNodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;int, SWCNode&gt; A single map of SWC nodes with sequential IDs representing the assembled neuron</dd></dl>
<p>This method takes multiple trunk segments and combines them into a single neuron representation while ensuring all node IDs are unique and sequential. It handles the remapping of parent-child relationships to maintain the neuron's topological structure.</p>
<p>Key features:</p><ul>
<li>Renumbers all node IDs sequentially starting from 1</li>
<li>Maintains parent-child relationships between nodes</li>
<li>Handles duplicate nodes across different trunks (uses first occurrence)</li>
<li>Ensures the root node has pid = -1</li>
</ul>
<p>The method performs two main passes:</p><ol type="1">
<li>First pass: Creates a mapping from old node IDs to new sequential IDs</li>
<li>Second pass: Updates all parent IDs using the new mapping</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>This method assumes that node IDs within each trunk have NOT been reset to start at 1. If the trunks have already been renumbered, use the other overload that takes a trunkParentMap. </dd>
<dd>
The resulting node IDs will be sequential and unique across all trunks. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a8067ed0a71ebcbfd9092d25aec536545" title="Combines resampled trunks using a parent-child relationship map.">assembleTrunks(const std::map&lt;int, std::map&lt;int, SWCNode&gt;&gt;&amp;, const std::map&lt;int,int&gt;&amp;)</a> for the version that handles parent-child relationships between trunks </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a7961eded24b6524392b01fdfa7e98452_icgraph.png" border="0" usemap="#aclassNeuronGraph_a7961eded24b6524392b01fdfa7e98452_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a7961eded24b6524392b01fdfa7e98452_icgraph" id="aclassNeuronGraph_a7961eded24b6524392b01fdfa7e98452_icgraph">
<area shape="rect" title="Combines multiple trunks into a single node set." alt="" coords="563,56,765,83"/>
<area shape="rect" href="classNeuronGraph.html#acbf58bd7db5d97c97ec95b63c679a62a" title="Generates multiple levels of refined neuron morphologies." alt="" coords="284,5,515,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="45,56,196,83"/>
<area shape="rect" href="callbacks_8cpp.html#a0b9e239c8889734711f29fe45551605b" title="Handles keyboard input events for the neuron viewer." alt="" coords="352,107,447,133"/>
<area shape="rect" href="classNeuronGraph.html#a607cb1a4a78a63ac33c462337f178b18" title=" " alt="" coords="5,5,236,32"/>
<area shape="rect" href="neuronviewer_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title=" " alt="" coords="95,107,146,133"/>
</map>
</div>

</div>
</div>
<a id="ae4a90fcdd47904cee5fc06b451e2d956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a90fcdd47904cee5fc06b451e2d956">&#9670;&nbsp;</a></span>cubicSplineResampleTrunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; NeuronGraph::cubicSplineResampleTrunk </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resamples a single trunk using cubic spline interpolation. </p>
<p>Resamples a single trunk segment using cubic spline interpolation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trunk</td><td>The trunk to resample (map of node IDs to SWCNodes) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">delta</td><td>Target spacing between resampled points (may be adjusted) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new set of nodes representing the resampled trunk</dd></dl>
<p>Cubic spline interpolation generally produces smoother curves than linear interpolation, especially for coarsely sampled data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunk</td><td>Map of node IDs to <a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> objects representing the trunk to be resampled </td></tr>
    <tr><td class="paramname">delta</td><td>Target distance between consecutive nodes in the resampled trunk (in microns) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;int, SWCNode&gt; A new map of resampled nodes with sequential IDs</dd></dl>
<p>This method performs cubic spline resampling of a neuron trunk to achieve a smooth and uniform distribution of nodes along its length. It creates a smooth curve that passes through all original nodes and samples new points along this curve.</p>
<p>Key features:</p><ul>
<li>Preserves the first and last nodes of the original trunk exactly</li>
<li>Fits natural cubic splines to x, y, and z coordinates separately</li>
<li>Parameterizes the spline by arc length for uniform sampling</li>
<li>Maintains the dominant node type throughout the resampled trunk</li>
<li>Handles 3D coordinates and radii with appropriate interpolation</li>
<li>Adjusts node IDs and parent IDs to maintain a valid tree structure</li>
</ul>
<p>The algorithm works as follows:</p><ol type="1">
<li>Converts the input trunk to an ordered vector of nodes</li>
<li>Determines the dominant node type in the trunk</li>
<li>Fits natural cubic splines to x, y, and z coordinates</li>
<li>Parameterizes the spline by arc length</li>
<li>Samples new points at approximately 'delta' intervals along the curve</li>
<li>Ensures the first and last nodes match the original exactly</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>This method produces smoother results than linear interpolation but is more computationally intensive </dd>
<dd>
The actual spacing may vary slightly to ensure the curve is sampled properly </dd>
<dd>
If the input trunk has fewer than 4 nodes, falls back to linear interpolation </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a198959fac3c6691530c888896ae777ae" title="Resamples all trunks using cubic spline interpolation.">allCubicSplineResampledTrunks()</a> for resampling multiple trunks </dd>
<dd>
<a class="el" href="classNeuronGraph.html#a4263b75e5c5c97d6f65dd681dbdfff60" title="Resamples a single trunk using linear interpolation.">linearSplineResampleTrunk()</a> for a faster but less smooth alternative </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_ae4a90fcdd47904cee5fc06b451e2d956_icgraph.png" border="0" usemap="#aclassNeuronGraph_ae4a90fcdd47904cee5fc06b451e2d956_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_ae4a90fcdd47904cee5fc06b451e2d956_icgraph" id="aclassNeuronGraph_ae4a90fcdd47904cee5fc06b451e2d956_icgraph">
<area shape="rect" title="Resamples a single trunk using cubic spline interpolation." alt="" coords="721,121,896,162"/>
<area shape="rect" href="classNeuronGraph.html#a198959fac3c6691530c888896ae777ae" title="Resamples all trunks using cubic spline interpolation." alt="" coords="483,70,673,111"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,56,156,83"/>
<area shape="rect" href="classNeuronGraph.html#acbf58bd7db5d97c97ec95b63c679a62a" title="Generates multiple levels of refined neuron morphologies." alt="" coords="204,5,435,32"/>
<area shape="rect" href="callbacks_8cpp.html#a0b9e239c8889734711f29fe45551605b" title="Handles keyboard input events for the neuron viewer." alt="" coords="272,107,367,133"/>
</map>
</div>

</div>
</div>
<a id="acbf58bd7db5d97c97ec95b63c679a62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf58bd7db5d97c97ec95b63c679a62a">&#9670;&nbsp;</a></span>generateRefinements() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt; NeuronGraph::generateRefinements </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates multiple levels of refined neuron morphologies. </p>
<p>Generates multiple levels of mesh refinements for a neuron morphology.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The set of nodes to refine </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">delta</td><td>Initial spacing parameter for refinement </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">N</td><td>Number of refinement levels to generate </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">method</td><td>Refinement method ("linear" or "cubic") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where keys are refinement levels and values are the refined node sets</dd></dl>
<p>This method generates a series of increasingly refined versions of the input neuron morphology by repeatedly applying the specified interpolation method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>Map of SWC nodes representing the input neuron morphology </td></tr>
    <tr><td class="paramname">delta</td><td>Initial target spacing between nodes (in microns). This value is halved in each refinement level. </td></tr>
    <tr><td class="paramname">N</td><td>Number of refinement levels to generate </td></tr>
    <tr><td class="paramname">method</td><td>Interpolation method to use ("linear" or "cubic") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;int, std::map&lt;int, SWCNode&gt;&gt; Map where each key is the refinement level (0 to N-1) and the value is the resampled neuron at that refinement level</dd></dl>
<p>This method creates a series of increasingly refined versions of the input neuron morphology. Each refinement level approximately halves the spacing between nodes, providing a multi-resolution representation of the neuron that can be used for progressive rendering or adaptive meshing.</p>
<p>Key features:</p><ul>
<li>Supports both linear and cubic spline interpolation methods</li>
<li>Progressively refines the mesh by halving 'delta' at each level</li>
<li>Maintains topological relationships between nodes</li>
<li>Preserves branch points and overall neuron structure</li>
<li>Returns all refinement levels for comparison or progressive loading</li>
</ul>
<p>The refinement process works as follows:</p><ol type="1">
<li>Extracts trunk segments from the input neuron</li>
<li>Determines parent-child relationships between trunks</li>
<li>For each refinement level i (0 to N-1): a. Resamples all trunks using the specified method with spacing delta/(2^i) b. Reassembles the neuron from the resampled trunks c. Stores the result in the output map</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The input 'delta' parameter will be modified during execution (halved at each level) </dd>
<dd>
If an unsupported method is provided, falls back to linear interpolation </dd>
<dd>
The first refinement level (i=0) uses the initial delta value </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a126fba2e060c47a5a20445af0622d06b" title="Resamples all trunks using linear interpolation.">allLinearSplineResampledTrunks()</a> for the linear interpolation implementation </dd>
<dd>
<a class="el" href="classNeuronGraph.html#a198959fac3c6691530c888896ae777ae" title="Resamples all trunks using cubic spline interpolation.">allCubicSplineResampledTrunks()</a> for the cubic spline implementation </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_acbf58bd7db5d97c97ec95b63c679a62a_cgraph.png" border="0" usemap="#aclassNeuronGraph_acbf58bd7db5d97c97ec95b63c679a62a_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_acbf58bd7db5d97c97ec95b63c679a62a_cgraph" id="aclassNeuronGraph_acbf58bd7db5d97c97ec95b63c679a62a_cgraph">
<area shape="rect" title="Generates multiple levels of refined neuron morphologies." alt="" coords="5,137,236,163"/>
<area shape="rect" href="classNeuronGraph.html#a198959fac3c6691530c888896ae777ae" title="Resamples all trunks using cubic spline interpolation." alt="" coords="299,5,490,47"/>
<area shape="rect" href="classNeuronGraph.html#a126fba2e060c47a5a20445af0622d06b" title="Resamples all trunks using linear interpolation." alt="" coords="299,71,490,112"/>
<area shape="rect" href="classNeuronGraph.html#a7961eded24b6524392b01fdfa7e98452" title="Combines multiple trunks into a single node set." alt="" coords="293,137,496,163"/>
<area shape="rect" href="classNeuronGraph.html#aa4a2201e3e2eddb93176ce3e84bfc619" title="Creates a mapping from trunk IDs to their parent trunk IDs." alt="" coords="284,187,505,214"/>
<area shape="rect" href="classNeuronGraph.html#ae750a60642aa3d1a30ec9265795cd065" title="Extracts trunk segments from a neuron morphology." alt="" coords="312,238,477,265"/>
<area shape="rect" href="classNeuronGraph.html#ae4a90fcdd47904cee5fc06b451e2d956" title="Resamples a single trunk using cubic spline interpolation." alt="" coords="567,5,742,47"/>
<area shape="rect" href="classNeuronGraph.html#a4263b75e5c5c97d6f65dd681dbdfff60" title="Resamples a single trunk using linear interpolation." alt="" coords="567,71,742,112"/>
<area shape="rect" href="classNeuronGraph.html#a76f4e1ec5197389c1c073a2c891a4e2e" title="Builds a neighbor map from a set of nodes." alt="" coords="553,238,756,265"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_acbf58bd7db5d97c97ec95b63c679a62a_icgraph.png" border="0" usemap="#aclassNeuronGraph_acbf58bd7db5d97c97ec95b63c679a62a_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_acbf58bd7db5d97c97ec95b63c679a62a_icgraph" id="aclassNeuronGraph_acbf58bd7db5d97c97ec95b63c679a62a_icgraph">
<area shape="rect" title="Generates multiple levels of refined neuron morphologies." alt="" coords="284,31,515,57"/>
<area shape="rect" href="classNeuronGraph.html#a607cb1a4a78a63ac33c462337f178b18" title=" " alt="" coords="5,5,236,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="45,56,196,83"/>
</map>
</div>

</div>
</div>
<a id="a607cb1a4a78a63ac33c462337f178b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607cb1a4a78a63ac33c462337f178b18">&#9670;&nbsp;</a></span>generateRefinements() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, std::map&lt;int,<a class="el" href="structSWCNode.html">SWCNode</a>&gt; &gt; NeuronGraph::generateRefinements </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Generates refinements for the current graph's nodes </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a607cb1a4a78a63ac33c462337f178b18_cgraph.png" border="0" usemap="#aclassNeuronGraph_a607cb1a4a78a63ac33c462337f178b18_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a607cb1a4a78a63ac33c462337f178b18_cgraph" id="aclassNeuronGraph_a607cb1a4a78a63ac33c462337f178b18_cgraph">
<area shape="rect" title=" " alt="" coords="5,137,236,163"/>
<area shape="rect" href="classNeuronGraph.html#acbf58bd7db5d97c97ec95b63c679a62a" title="Generates multiple levels of refined neuron morphologies." alt="" coords="284,137,515,163"/>
<area shape="rect" href="classNeuronGraph.html#a198959fac3c6691530c888896ae777ae" title="Resamples all trunks using cubic spline interpolation." alt="" coords="578,5,769,47"/>
<area shape="rect" href="classNeuronGraph.html#a126fba2e060c47a5a20445af0622d06b" title="Resamples all trunks using linear interpolation." alt="" coords="578,71,769,112"/>
<area shape="rect" href="classNeuronGraph.html#a7961eded24b6524392b01fdfa7e98452" title="Combines multiple trunks into a single node set." alt="" coords="572,137,775,163"/>
<area shape="rect" href="classNeuronGraph.html#aa4a2201e3e2eddb93176ce3e84bfc619" title="Creates a mapping from trunk IDs to their parent trunk IDs." alt="" coords="563,187,784,214"/>
<area shape="rect" href="classNeuronGraph.html#ae750a60642aa3d1a30ec9265795cd065" title="Extracts trunk segments from a neuron morphology." alt="" coords="591,238,756,265"/>
</map>
</div>

</div>
</div>
<a id="a76f4e1ec5197389c1c073a2c891a4e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f4e1ec5197389c1c073a2c891a4e2e">&#9670;&nbsp;</a></span>getNeighborMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, std::vector&lt; int &gt; &gt; NeuronGraph::getNeighborMap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a neighbor map from a set of nodes. </p>
<p>Builds an adjacency list representing the connectivity between nodes in a neuron morphology.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>Set of nodes to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map where each key is a node ID and the value is a list of neighbor node IDs</dd></dl>
<p>This helper function constructs an adjacency list representation of the graph from a set of nodes by establishing parent-child relationships.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>Map of SWC nodes where key is node ID and value is the <a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;int, std::vector&lt;int&gt;&gt; where each key is a node ID and value is a vector of its neighbor node IDs</dd></dl>
<p>This method constructs an undirected graph representation of the neuron morphology by creating neighbor relationships between connected nodes. For each node in the input set, it establishes bidirectional connections between the node and its parent (if the parent exists in the nodeSet).</p>
<p>The resulting neighbor map allows efficient traversal of the neuron's topology in any direction, which is essential for various analysis and processing tasks such as trunk extraction and topological sorting.</p>
<dl class="section note"><dt>Note</dt><dd>Only nodes present in the input nodeSet are included in the neighbor map </dd>
<dd>
The method creates bidirectional edges (A→B and B→A) for each parent-child relationship </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#ae750a60642aa3d1a30ec9265795cd065" title="Extracts trunk segments from a neuron morphology.">getTrunks()</a> for the primary use of this method </dd>
<dd>
<a class="el" href="classNeuronGraph.html#ab66e25466d6c0b228b95c118963e7cb0" title="Sorts nodes topologically using Kahn&#39;s algorithm.">topologicalSort()</a> for another application of the neighbor map </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a76f4e1ec5197389c1c073a2c891a4e2e_icgraph.png" border="0" usemap="#aclassNeuronGraph_a76f4e1ec5197389c1c073a2c891a4e2e_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a76f4e1ec5197389c1c073a2c891a4e2e_icgraph" id="aclassNeuronGraph_a76f4e1ec5197389c1c073a2c891a4e2e_icgraph">
<area shape="rect" title="Builds a neighbor map from a set of nodes." alt="" coords="696,81,899,108"/>
<area shape="rect" href="classNeuronGraph.html#ae750a60642aa3d1a30ec9265795cd065" title="Extracts trunk segments from a neuron morphology." alt="" coords="483,81,648,108"/>
<area shape="rect" href="classNeuronGraph.html#acbf58bd7db5d97c97ec95b63c679a62a" title="Generates multiple levels of refined neuron morphologies." alt="" coords="204,5,435,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,31,156,57"/>
<area shape="rect" href="callbacks_8cpp.html#a0b9e239c8889734711f29fe45551605b" title="Handles keyboard input events for the neuron viewer." alt="" coords="272,107,367,133"/>
<area shape="rect" href="extracttrunks_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="294,157,345,184"/>
</map>
</div>

</div>
</div>
<a id="aadf6c2dcb7cd1aa1d3664009eede14be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf6c2dcb7cd1aa1d3664009eede14be">&#9670;&nbsp;</a></span>getNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto NeuronGraph::getNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of all nodes in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>A map of node IDs to <a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> objects </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_aadf6c2dcb7cd1aa1d3664009eede14be_icgraph.png" border="0" usemap="#aclassNeuronGraph_aadf6c2dcb7cd1aa1d3664009eede14be_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_aadf6c2dcb7cd1aa1d3664009eede14be_icgraph" id="aclassNeuronGraph_aadf6c2dcb7cd1aa1d3664009eede14be_icgraph">
<area shape="rect" title="Returns a copy of all nodes in the graph." alt="" coords="365,81,528,108"/>
<area shape="rect" href="opgl__utils_8cpp.html#adda0a7f12116617440260139feb5ae46" title="Loads a neuron morphology from an SWC or UGX file." alt="" coords="203,31,281,57"/>
<area shape="rect" href="main_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="217,81,267,108"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="167,132,317,159"/>
<area shape="rect" href="neuronviewer_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title=" " alt="" coords="37,5,87,32"/>
<area shape="rect" href="opgl__utils_8cpp.html#a81fad3cb23594d5bbd0c49fbe109379b" title="Opens a file dialog and loads a neuron morphology file." alt="" coords="5,56,119,83"/>
</map>
</div>

</div>
</div>
<a id="aa4a2201e3e2eddb93176ce3e84bfc619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a2201e3e2eddb93176ce3e84bfc619">&#9670;&nbsp;</a></span>getTrunkParentMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, int &gt; NeuronGraph::getTrunkParentMap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>trunkNodeSets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a mapping from trunk IDs to their parent trunk IDs. </p>
<p>Determines the parent-child relationships between trunk segments in a neuron morphology.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The original set of nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trunkNodeSets</td><td>Map of trunk IDs to their nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where keys are trunk IDs and values are parent trunk IDs (-1 for root trunks)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>Original map of all SWC nodes in the neuron </td></tr>
    <tr><td class="paramname">trunkNodeSets</td><td>Map of trunk segments where each key is a trunk ID and value is a map of node IDs to SWCNodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;int, int&gt; Map where each key is a trunk ID and value is its parent trunk ID (-1 for root trunks)</dd></dl>
<p>This method analyzes the connectivity between trunk segments to establish a hierarchical parent-child relationship between them. It determines which trunk connects to which by examining the parent-child relationships of the nodes at the connection points between trunks.</p>
<p>The algorithm works in two main phases:</p><ol type="1">
<li>Builds a reverse lookup (node ID → trunk ID) to quickly find which trunk a node belongs to</li>
<li>For each trunk, examines the parent of its first node to determine its parent trunk</li>
</ol>
<p>Key assumptions:</p><ul>
<li>The first node in each trunk's node map is the rootward (proximal) end of the trunk</li>
<li>Trunks are topologically sorted with parent nodes appearing before their children</li>
<li>The input trunks have already been extracted and may have been processed (e.g., resampled)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>A return value of -1 indicates a root trunk (no parent) </dd>
<dd>
If a trunk's first node has no parent or its parent is not in any trunk, it's considered a root trunk </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#ae750a60642aa3d1a30ec9265795cd065" title="Extracts trunk segments from a neuron morphology.">getTrunks()</a> for how trunks are initially extracted </dd>
<dd>
<a class="el" href="classNeuronGraph.html#a7961eded24b6524392b01fdfa7e98452" title="Combines multiple trunks into a single node set.">assembleTrunks()</a> for how this parent information is used in reconstruction </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_aa4a2201e3e2eddb93176ce3e84bfc619_icgraph.png" border="0" usemap="#aclassNeuronGraph_aa4a2201e3e2eddb93176ce3e84bfc619_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_aa4a2201e3e2eddb93176ce3e84bfc619_icgraph" id="aclassNeuronGraph_aa4a2201e3e2eddb93176ce3e84bfc619_icgraph">
<area shape="rect" title="Creates a mapping from trunk IDs to their parent trunk IDs." alt="" coords="563,56,784,83"/>
<area shape="rect" href="classNeuronGraph.html#acbf58bd7db5d97c97ec95b63c679a62a" title="Generates multiple levels of refined neuron morphologies." alt="" coords="284,5,515,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="45,56,196,83"/>
<area shape="rect" href="callbacks_8cpp.html#a0b9e239c8889734711f29fe45551605b" title="Handles keyboard input events for the neuron viewer." alt="" coords="352,107,447,133"/>
<area shape="rect" href="classNeuronGraph.html#a607cb1a4a78a63ac33c462337f178b18" title=" " alt="" coords="5,5,236,32"/>
<area shape="rect" href="neuronviewer_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title=" " alt="" coords="95,107,146,133"/>
</map>
</div>

</div>
</div>
<a id="a74bfbcdde59807456a3ed21aa244fe48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bfbcdde59807456a3ed21aa244fe48">&#9670;&nbsp;</a></span>getTrunks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int,std::map&lt;int,<a class="el" href="structSWCNode.html">SWCNode</a>&gt; &gt; NeuronGraph::getTrunks </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetIndex</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Extracts trunk segments from the current graph </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a74bfbcdde59807456a3ed21aa244fe48_cgraph.png" border="0" usemap="#aclassNeuronGraph_a74bfbcdde59807456a3ed21aa244fe48_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a74bfbcdde59807456a3ed21aa244fe48_cgraph" id="aclassNeuronGraph_a74bfbcdde59807456a3ed21aa244fe48_cgraph">
<area shape="rect" title=" " alt="" coords="5,29,171,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a74bfbcdde59807456a3ed21aa244fe48_icgraph.png" border="0" usemap="#aclassNeuronGraph_a74bfbcdde59807456a3ed21aa244fe48_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a74bfbcdde59807456a3ed21aa244fe48_icgraph" id="aclassNeuronGraph_a74bfbcdde59807456a3ed21aa244fe48_icgraph">
<area shape="rect" title=" " alt="" coords="5,29,171,56"/>
</map>
</div>

</div>
</div>
<a id="ae750a60642aa3d1a30ec9265795cd065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae750a60642aa3d1a30ec9265795cd065">&#9670;&nbsp;</a></span>getTrunks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt; NeuronGraph::getTrunks </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resetIndex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts trunk segments from a neuron morphology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The set of nodes to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resetIndex</td><td>If true, renumbers node IDs sequentially </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where each key is a trunk ID and the value is a map of node IDs to SWCNodes</dd></dl>
<p>A trunk is defined as a linear segment between branch points or between a branch point and a leaf node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>Map of SWC nodes where key is node ID and value is the <a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> object </td></tr>
    <tr><td class="paramname">resetIndex</td><td>If true, renumbers node IDs sequentially within each trunk (default: false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;int, std::map&lt;int, SWCNode&gt;&gt; where each key is a trunk ID and value is a map of node IDs to SWCNodes in that trunk</dd></dl>
<p>This method identifies and extracts linear segments (trunks) from a neuron morphology. A trunk is defined as a path between:</p><ul>
<li>Two branch points (nodes with degree &gt; 2)</li>
<li>A branch point and an endpoint (node with degree 1)</li>
<li>The root node and the first branch point</li>
</ul>
<p>The algorithm works as follows:</p><ol type="1">
<li>Builds a neighbor map to represent the neuron's connectivity</li>
<li>Identifies branch points (nodes with &gt;2 neighbors)</li>
<li>For each branch point, traverses to connected nodes to extract linear segments</li>
<li>Uses canonical representation to avoid duplicate trunks</li>
<li>Optionally renumbers node IDs sequentially within each trunk</li>
</ol>
<p>The method handles both directed and undirected traversal of the neuron morphology.</p>
<dl class="section note"><dt>Note</dt><dd>When resetIndex is true, node IDs within each trunk will be renumbered sequentially starting from 1, with parent IDs adjusted accordingly. The first node in each trunk will have pid = -1. </dd>
<dd>
The method uses a canonical representation to ensure each trunk is only included once, regardless of traversal direction. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a76f4e1ec5197389c1c073a2c891a4e2e" title="Builds a neighbor map from a set of nodes.">getNeighborMap()</a> for the <a class="el" href="globals_8h.html#a65b5e8f0673c2dba7ec632133f036a21" title="The main neuron graph data structure.">graph</a> representation used internally </dd>
<dd>
<a class="el" href="classNeuronGraph.html#aa4a2201e3e2eddb93176ce3e84bfc619" title="Creates a mapping from trunk IDs to their parent trunk IDs.">getTrunkParentMap()</a> for establishing relationships between trunks </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_ae750a60642aa3d1a30ec9265795cd065_cgraph.png" border="0" usemap="#aclassNeuronGraph_ae750a60642aa3d1a30ec9265795cd065_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_ae750a60642aa3d1a30ec9265795cd065_cgraph" id="aclassNeuronGraph_ae750a60642aa3d1a30ec9265795cd065_cgraph">
<area shape="rect" title="Extracts trunk segments from a neuron morphology." alt="" coords="5,5,171,32"/>
<area shape="rect" href="classNeuronGraph.html#a76f4e1ec5197389c1c073a2c891a4e2e" title="Builds a neighbor map from a set of nodes." alt="" coords="219,5,421,32"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_ae750a60642aa3d1a30ec9265795cd065_icgraph.png" border="0" usemap="#aclassNeuronGraph_ae750a60642aa3d1a30ec9265795cd065_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_ae750a60642aa3d1a30ec9265795cd065_icgraph" id="aclassNeuronGraph_ae750a60642aa3d1a30ec9265795cd065_icgraph">
<area shape="rect" title="Extracts trunk segments from a neuron morphology." alt="" coords="563,81,728,108"/>
<area shape="rect" href="classNeuronGraph.html#acbf58bd7db5d97c97ec95b63c679a62a" title="Generates multiple levels of refined neuron morphologies." alt="" coords="284,5,515,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="45,56,196,83"/>
<area shape="rect" href="callbacks_8cpp.html#a0b9e239c8889734711f29fe45551605b" title="Handles keyboard input events for the neuron viewer." alt="" coords="352,107,447,133"/>
<area shape="rect" href="extracttrunks_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="374,157,425,184"/>
<area shape="rect" href="classNeuronGraph.html#a607cb1a4a78a63ac33c462337f178b18" title=" " alt="" coords="5,5,236,32"/>
<area shape="rect" href="neuronviewer_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title=" " alt="" coords="95,107,146,133"/>
</map>
</div>

</div>
</div>
<a id="ade30f063c2aeaaa9817606497f16875b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade30f063c2aeaaa9817606497f16875b">&#9670;&nbsp;</a></span>hasSomaSegment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NeuronGraph::hasSomaSegment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Checks if the current graph contains a soma segment </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_ade30f063c2aeaaa9817606497f16875b_cgraph.png" border="0" usemap="#aclassNeuronGraph_ade30f063c2aeaaa9817606497f16875b_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_ade30f063c2aeaaa9817606497f16875b_cgraph" id="aclassNeuronGraph_ade30f063c2aeaaa9817606497f16875b_cgraph">
<area shape="rect" title=" " alt="" coords="5,29,220,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_ade30f063c2aeaaa9817606497f16875b_icgraph.png" border="0" usemap="#aclassNeuronGraph_ade30f063c2aeaaa9817606497f16875b_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_ade30f063c2aeaaa9817606497f16875b_icgraph" id="aclassNeuronGraph_ade30f063c2aeaaa9817606497f16875b_icgraph">
<area shape="rect" title=" " alt="" coords="204,29,419,56"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,29,156,56"/>
</map>
</div>

</div>
</div>
<a id="abc081d9ef1972cbc262571246698f0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc081d9ef1972cbc262571246698f0f2">&#9670;&nbsp;</a></span>hasSomaSegment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NeuronGraph::hasSomaSegment </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the node set contains a soma segment. </p>
<p>Checks if the neuron has multiple soma nodes (soma segment)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The set of nodes to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a soma segment is found, false otherwise</dd></dl>
<p>A soma segment is defined as multiple connected nodes of type 1 (soma).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>Map of SWC nodes to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if multiple soma nodes exist, false otherwise</dd></dl>
<p>This method detects the presence of soma segments, which occur when multiple nodes have type 1 (soma). In proper neuron morphology, there should be exactly one soma node. Multiple soma nodes can cause issues in analysis and mesh generation.</p>
<p>The method uses early exit optimization - it returns true as soon as a second soma node is found, avoiding unnecessary iterations.</p>
<dl class="section note"><dt>Note</dt><dd>Soma nodes are identified by type == 1 in SWC format </dd>
<dd>
This is used in preprocessing to clean up neuron data</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a48d21c08d8a35dd270a0aa8032c4fe35" title="Applies standard preprocessing steps to a set of nodes.">preprocess()</a> for automatic soma segment removal </dd>
<dd>
<a class="el" href="classNeuronGraph.html#aed5eb4290d85b7a134f95fa5b453ba50" title="Removes the soma segment from a set of nodes.">removeSomaSegment()</a> for soma segment correction </dd></dl>

</div>
</div>
<a id="ae25c92d56c3019385447d3dc7ab86346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25c92d56c3019385447d3dc7ab86346">&#9670;&nbsp;</a></span>isSomaMissing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NeuronGraph::isSomaMissing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Checks if the current graph is missing a soma </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_ae25c92d56c3019385447d3dc7ab86346_cgraph.png" border="0" usemap="#aclassNeuronGraph_ae25c92d56c3019385447d3dc7ab86346_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_ae25c92d56c3019385447d3dc7ab86346_cgraph" id="aclassNeuronGraph_ae25c92d56c3019385447d3dc7ab86346_cgraph">
<area shape="rect" title=" " alt="" coords="5,29,201,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_ae25c92d56c3019385447d3dc7ab86346_icgraph.png" border="0" usemap="#aclassNeuronGraph_ae25c92d56c3019385447d3dc7ab86346_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_ae25c92d56c3019385447d3dc7ab86346_icgraph" id="aclassNeuronGraph_ae25c92d56c3019385447d3dc7ab86346_icgraph">
<area shape="rect" title=" " alt="" coords="212,31,408,57"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="9,5,160,32"/>
<area shape="rect" href="classNeuronGraph.html#a4da98a459bd4ddaa00df5ed08bc80477" title="Adds a soma node if none exists." alt="" coords="5,56,164,83"/>
</map>
</div>

</div>
</div>
<a id="a84a4ee923b6547a3d2fa7c8953932ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a4ee923b6547a3d2fa7c8953932ed0">&#9670;&nbsp;</a></span>isSomaMissing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NeuronGraph::isSomaMissing </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the node set is missing a soma. </p>
<p>Checks if the neuron is missing a soma node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The set of nodes to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if no soma is present, false otherwise</dd></dl>
<p>This is the inverse of <a class="el" href="classNeuronGraph.html#abc081d9ef1972cbc262571246698f0f2" title="Checks if the node set contains a soma segment.">hasSomaSegment()</a> and is provided for readability.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>Map of SWC nodes to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if no soma node exists, false if soma is present</dd></dl>
<p>This method determines whether the neuron morphology lacks a soma (cell body). Every valid neuron should have exactly one soma node of type 1. Missing somas can occur in incomplete reconstructions or when dealing with neuron fragments.</p>
<p>The method uses early exit - it returns false as soon as any soma node is found, making it efficient for large neuron datasets.</p>
<dl class="section note"><dt>Note</dt><dd>Soma nodes are identified by type == 1 in SWC format </dd>
<dd>
This is used in preprocessing to add missing somas</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a48d21c08d8a35dd270a0aa8032c4fe35" title="Applies standard preprocessing steps to a set of nodes.">preprocess()</a> for automatic soma addition </dd>
<dd>
<a class="el" href="classNeuronGraph.html#a4da98a459bd4ddaa00df5ed08bc80477" title="Adds a soma node if none exists.">setSoma()</a> for adding missing soma <a class="el" href="classNeuronGraph.html#a312adb405dceafb6b1a736bd8e4ded88" title="Map of node IDs to SWCNode objects.">nodes</a> </dd></dl>

</div>
</div>
<a id="a0a94b95b0afc5d98590e631f963a970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a94b95b0afc5d98590e631f963a970d">&#9670;&nbsp;</a></span>isTopologicallySorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NeuronGraph::isTopologicallySorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Checks if the current graph's nodes are topologically sorted </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a0a94b95b0afc5d98590e631f963a970d_cgraph.png" border="0" usemap="#aclassNeuronGraph_a0a94b95b0afc5d98590e631f963a970d_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a0a94b95b0afc5d98590e631f963a970d_cgraph" id="aclassNeuronGraph_a0a94b95b0afc5d98590e631f963a970d_cgraph">
<area shape="rect" title=" " alt="" coords="5,29,197,71"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a0a94b95b0afc5d98590e631f963a970d_icgraph.png" border="0" usemap="#aclassNeuronGraph_a0a94b95b0afc5d98590e631f963a970d_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a0a94b95b0afc5d98590e631f963a970d_icgraph" id="aclassNeuronGraph_a0a94b95b0afc5d98590e631f963a970d_icgraph">
<area shape="rect" title=" " alt="" coords="388,49,580,90"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="147,5,297,32"/>
<area shape="rect" href="classNeuronGraph.html#aed5eb4290d85b7a134f95fa5b453ba50" title="Removes the soma segment from a set of nodes." alt="" coords="104,56,340,83"/>
<area shape="rect" href="classNeuronGraph.html#a4dd02c37f81fc7d5cfbb929bd25e1fa2" title="Splits all edges in the graph by inserting midpoint nodes." alt="" coords="138,107,306,133"/>
<area shape="rect" href="extracttrunks_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="5,56,56,83"/>
<area shape="rect" href="splitrefine_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="5,107,56,133"/>
</map>
</div>

</div>
</div>
<a id="a7b7eae0aeccf7e7aec8f3cab6008f37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7eae0aeccf7e7aec8f3cab6008f37c">&#9670;&nbsp;</a></span>isTopologicallySorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NeuronGraph::isTopologicallySorted </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a set of nodes is topologically sorted. </p>
<p>Checks if the neuron nodes are topologically sorted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The set of nodes to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the nodes are topologically sorted, false otherwise</dd></dl>
<p>A set of nodes is considered topologically sorted if for every node, its parent ID is less than its own ID (i.e., parent nodes come before their children in the sequence).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>Map of SWC nodes to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if nodes are topologically sorted, false otherwise</dd></dl>
<p>This method verifies that all parent nodes have IDs smaller than their children nodes (parent_id &lt; child_id). This property is important for many neuron analysis algorithms and ensures proper tree traversal.</p>
<p>A topologically sorted neuron means that when nodes are processed in ID order, all parent nodes are encountered before their children.</p>
<dl class="section note"><dt>Note</dt><dd>Root nodes (pid == -1) are always considered valid </dd>
<dd>
The commented debug output can be uncommented for troubleshooting</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> structure for node ID and parent ID fields </dd></dl>

</div>
</div>
<a id="a4263b75e5c5c97d6f65dd681dbdfff60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4263b75e5c5c97d6f65dd681dbdfff60">&#9670;&nbsp;</a></span>linearSplineResampleTrunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; NeuronGraph::linearSplineResampleTrunk </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resamples a single trunk using linear interpolation. </p>
<p>Resamples a single trunk segment using linear interpolation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trunk</td><td>The trunk to resample (map of node IDs to SWCNodes) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">delta</td><td>Target spacing between resampled points (may be adjusted) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new set of nodes representing the resampled trunk</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunk</td><td>Map of node IDs to <a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> objects representing the trunk to be resampled </td></tr>
    <tr><td class="paramname">delta</td><td>Target distance between consecutive nodes in the resampled trunk (in microns) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;int, SWCNode&gt; A new map of resampled nodes with sequential IDs</dd></dl>
<p>This method performs linear resampling of a neuron trunk to achieve a more uniform distribution of nodes along its length. It creates a piecewise linear approximation of the original trunk with nodes spaced approximately 'delta' units apart.</p>
<p>Key features:</p><ul>
<li>Preserves the first and last nodes of the original trunk exactly</li>
<li>Uses linear interpolation between existing nodes</li>
<li>Maintains the dominant node type throughout the resampled trunk</li>
<li>Adjusts node IDs and parent IDs to maintain a valid tree structure</li>
<li>Handles 3D coordinates and radii</li>
</ul>
<p>The algorithm works as follows:</p><ol type="1">
<li>Converts the input trunk to an ordered vector of nodes</li>
<li>Determines the dominant node type in the trunk</li>
<li>Calculates the total arc length of the trunk</li>
<li>Determines the number of segments needed based on 'delta'</li>
<li>Performs linear interpolation between existing nodes to create new points</li>
<li>Ensures the first and last nodes match the original exactly</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The actual spacing may vary slightly to ensure the first and last nodes are preserved exactly </dd>
<dd>
If the input trunk has fewer than 2 nodes, returns an empty map </dd>
<dd>
The minimum number of points in the resampled trunk is 4 to ensure reasonable shape representation </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a126fba2e060c47a5a20445af0622d06b" title="Resamples all trunks using linear interpolation.">allLinearSplineResampledTrunks()</a> for resampling multiple trunks </dd>
<dd>
<a class="el" href="classNeuronGraph.html#ae4a90fcdd47904cee5fc06b451e2d956" title="Resamples a single trunk using cubic spline interpolation.">cubicSplineResampleTrunk()</a> for a smoother but more computationally intensive alternative </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a4263b75e5c5c97d6f65dd681dbdfff60_icgraph.png" border="0" usemap="#aclassNeuronGraph_a4263b75e5c5c97d6f65dd681dbdfff60_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a4263b75e5c5c97d6f65dd681dbdfff60_icgraph" id="aclassNeuronGraph_a4263b75e5c5c97d6f65dd681dbdfff60_icgraph">
<area shape="rect" title="Resamples a single trunk using linear interpolation." alt="" coords="721,70,896,111"/>
<area shape="rect" href="classNeuronGraph.html#a126fba2e060c47a5a20445af0622d06b" title="Resamples all trunks using linear interpolation." alt="" coords="483,41,673,82"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,56,156,83"/>
<area shape="rect" href="classNeuronGraph.html#acbf58bd7db5d97c97ec95b63c679a62a" title="Generates multiple levels of refined neuron morphologies." alt="" coords="204,5,435,32"/>
</map>
</div>

</div>
</div>
<a id="ad7d477e87f08f5d83df1e22b3e2f31ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d477e87f08f5d83df1e22b3e2f31ef">&#9670;&nbsp;</a></span>numberOfEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NeuronGraph::numberOfEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of edges in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of edges </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_ad7d477e87f08f5d83df1e22b3e2f31ef_icgraph.png" border="0" usemap="#aclassNeuronGraph_ad7d477e87f08f5d83df1e22b3e2f31ef_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_ad7d477e87f08f5d83df1e22b3e2f31ef_icgraph" id="aclassNeuronGraph_ad7d477e87f08f5d83df1e22b3e2f31ef_icgraph">
<area shape="rect" title="Returns the number of edges in the graph." alt="" coords="204,31,405,57"/>
<area shape="rect" href="extracttrunks_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="55,5,106,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,56,156,83"/>
</map>
</div>

</div>
</div>
<a id="a95079dcc37ed05aae8680eacf1fad317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95079dcc37ed05aae8680eacf1fad317">&#9670;&nbsp;</a></span>numberOfNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NeuronGraph::numberOfNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nodes in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of nodes </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a95079dcc37ed05aae8680eacf1fad317_icgraph.png" border="0" usemap="#aclassNeuronGraph_a95079dcc37ed05aae8680eacf1fad317_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a95079dcc37ed05aae8680eacf1fad317_icgraph" id="aclassNeuronGraph_a95079dcc37ed05aae8680eacf1fad317_icgraph">
<area shape="rect" title="Returns the number of nodes in the graph." alt="" coords="204,31,407,57"/>
<area shape="rect" href="extracttrunks_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="55,5,106,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,56,156,83"/>
</map>
</div>

</div>
</div>
<a id="a48d21c08d8a35dd270a0aa8032c4fe35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d21c08d8a35dd270a0aa8032c4fe35">&#9670;&nbsp;</a></span>preprocess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; NeuronGraph::preprocess </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies standard preprocessing steps to a set of nodes. </p>
<p>Preprocesses a node set to ensure proper soma properties.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The set of nodes to preprocess </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new set of preprocessed nodes</dd></dl>
<p>Preprocessing includes:</p><ol type="1">
<li>Topological sorting</li>
<li>Soma segment handling</li>
<li>Soma addition if missing</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>The input map of SWC nodes to preprocess </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A preprocessed map of SWC nodes with corrected soma properties</dd></dl>
<p>This method performs essential preprocessing steps on neuron data:</p><ol type="1">
<li>Checks if soma is missing and adds one if necessary</li>
<li>Removes soma segments if multiple soma nodes exist</li>
</ol>
<p>The preprocessing ensures that the neuron has exactly one soma node, which is critical for proper neuron analysis and mesh generation.</p>
<dl class="section see"><dt>See also</dt><dd>isSomaMissing(const std::map&lt;int, SWCNode&gt;&amp; nodeSet) </dd>
<dd>
hasSomaSegment(const std::map&lt;int, SWCNode&gt;&amp; nodeSet) </dd>
<dd>
setSoma(const std::map&lt;int, SWCNode&gt;&amp; nodeSet) </dd>
<dd>
removeSomaSegment(const std::map&lt;int, SWCNode&gt;&amp; nodeSet) </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a48d21c08d8a35dd270a0aa8032c4fe35_icgraph.png" border="0" usemap="#aclassNeuronGraph_a48d21c08d8a35dd270a0aa8032c4fe35_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a48d21c08d8a35dd270a0aa8032c4fe35_icgraph" id="aclassNeuronGraph_a48d21c08d8a35dd270a0aa8032c4fe35_icgraph">
<area shape="rect" title="Applies standard preprocessing steps to a set of nodes." alt="" coords="365,56,536,83"/>
<area shape="rect" href="opgl__utils_8cpp.html#adda0a7f12116617440260139feb5ae46" title="Loads a neuron morphology from an SWC or UGX file." alt="" coords="203,31,281,57"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="167,81,317,108"/>
<area shape="rect" href="neuronviewer_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title=" " alt="" coords="37,5,87,32"/>
<area shape="rect" href="opgl__utils_8cpp.html#a81fad3cb23594d5bbd0c49fbe109379b" title="Opens a file dialog and loads a neuron morphology file." alt="" coords="5,56,119,83"/>
</map>
</div>

</div>
</div>
<a id="a8ee6517767cd316da4474cb55c67307f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee6517767cd316da4474cb55c67307f">&#9670;&nbsp;</a></span>readFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NeuronGraph::readFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads neuron data from an SWC file. </p>
<p>Reads neuron morphology data from an SWC format file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to the SWC file to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the file cannot be opened or parsed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html">http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to the SWC file to read</td></tr>
  </table>
  </dd>
</dl>
<p>This method parses an SWC (Standardized Morphology Format) file and populates the graph with neuron nodes. The SWC format contains one node per line with the following columns: ID, type, x, y, z, radius, parent_ID.</p>
<p>The parser handles:</p><ul>
<li>Comment lines (starting with #)</li>
<li>Inline comments</li>
<li>Whitespace normalization</li>
<li>Tab-to-space conversion</li>
<li>Error reporting for malformed lines</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Clears existing graph data before loading new data </dd>
<dd>
Prints summary information upon successful completion </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If file cannot be opened, an error message is printed and method returns</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a453e31c723b0dc9d692d8663d93be51a" title="Adds a single node to the graph.">addNode(const SWCNode&amp; node)</a> for individual node processing </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a8ee6517767cd316da4474cb55c67307f_icgraph.png" border="0" usemap="#aclassNeuronGraph_a8ee6517767cd316da4474cb55c67307f_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a8ee6517767cd316da4474cb55c67307f_icgraph" id="aclassNeuronGraph_a8ee6517767cd316da4474cb55c67307f_icgraph">
<area shape="rect" title="Reads neuron data from an SWC file." alt="" coords="204,31,387,57"/>
<area shape="rect" href="extracttrunks_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="55,5,106,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,56,156,83"/>
</map>
</div>

</div>
</div>
<a id="a8742e842a6ce2eb1981d36ba9a8317fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8742e842a6ce2eb1981d36ba9a8317fb">&#9670;&nbsp;</a></span>readFromFileUGX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NeuronGraph::readFromFileUGX </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads neuron data from a UGX file. </p>
<p>Reads neuron morphology data from a UGX file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to the UGX file to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the file cannot be opened or parsed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>UGX is an XML-based format used by the UG4 simulation framework</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to the input UGX file to read</td></tr>
  </table>
  </dd>
</dl>
<p>This method imports neuron morphology data from a UGX file and populates the internal data structures of the <a class="el" href="classNeuronGraph.html" title="Class for representing and processing neuron morphology graphs.">NeuronGraph</a> class. It handles the conversion from the UGX format to the internal SWC-based representation.</p>
<p>The method processes the following UGX elements:</p><ul>
<li>Vertex coordinates (3D positions)</li>
<li>Edge connectivity between nodes</li>
<li>Vertex attributes (diameters, types, etc.)</li>
<li>Subset information for different neuron components</li>
</ul>
<p>The import process includes:</p><ol type="1">
<li>Parsing the XML structure of the UGX file</li>
<li>Extracting vertex coordinates and creating SWC nodes</li>
<li>Reconstructing parent-child relationships from edges</li>
<li>Loading additional attributes like diameters and node types</li>
<li>Validating the imported morphology</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The method clears any existing neuron data before importing </dd>
<dd>
If the file cannot be read or is malformed, error messages are printed to stderr </dd>
<dd>
The method attempts to map UGX subsets back to SWC node types when possible </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a938d33cc1ee5a5abc291c555e0a60ad5" title="Writes a set of nodes to a UGX file.">writeToFileUGX()</a> for the corresponding export functionality </dd>
<dd>
<a href="https://github.com/UG4/ug4">https://github.com/UG4/ug4</a> for more information about the UGX format </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a8742e842a6ce2eb1981d36ba9a8317fb_icgraph.png" border="0" usemap="#aclassNeuronGraph_a8742e842a6ce2eb1981d36ba9a8317fb_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a8742e842a6ce2eb1981d36ba9a8317fb_icgraph" id="aclassNeuronGraph_a8742e842a6ce2eb1981d36ba9a8317fb_icgraph">
<area shape="rect" title="Reads neuron data from a UGX file." alt="" coords="204,5,416,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,5,156,32"/>
</map>
</div>

</div>
</div>
<a id="a1c8deb90cf431df071765a400ddb144c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8deb90cf431df071765a400ddb144c">&#9670;&nbsp;</a></span>readFromFileUGXorSWC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NeuronGraph::readFromFileUGXorSWC </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a neuron file, automatically detecting the format. </p>
<p>Automatically detects file format and reads neuron data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to the neuron file (SWC or UGX)</td></tr>
  </table>
  </dd>
</dl>
<p>This method examines the file extension to determine whether to use <a class="el" href="classNeuronGraph.html#a8ee6517767cd316da4474cb55c67307f" title="Reads neuron data from an SWC file.">readFromFile()</a> or <a class="el" href="classNeuronGraph.html#a8742e842a6ce2eb1981d36ba9a8317fb" title="Reads neuron data from a UGX file.">readFromFileUGX()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the file format is not supported</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path to the input file (SWC or UGX format)</td></tr>
  </table>
  </dd>
</dl>
<p>This method automatically determines the file format based on the file extension and calls the appropriate reader method:</p><ul>
<li>.swc files are read using <a class="el" href="classNeuronGraph.html#a8ee6517767cd316da4474cb55c67307f" title="Reads neuron data from an SWC file.">readFromFile()</a></li>
<li>.ugx files are read using <a class="el" href="classNeuronGraph.html#a8742e842a6ce2eb1981d36ba9a8317fb" title="Reads neuron data from a UGX file.">readFromFileUGX()</a></li>
</ul>
<p>This provides a convenient unified interface for loading neuron data regardless of the input format.</p>
<dl class="section warning"><dt>Warning</dt><dd>Prints error message for unsupported file extensions</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a8ee6517767cd316da4474cb55c67307f" title="Reads neuron data from an SWC file.">readFromFile(const std::string&amp; filename)</a> for SWC format </dd>
<dd>
<a class="el" href="classNeuronGraph.html#a8742e842a6ce2eb1981d36ba9a8317fb" title="Reads neuron data from a UGX file.">readFromFileUGX(const std::string&amp; filename)</a> for UGX format </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a1c8deb90cf431df071765a400ddb144c_icgraph.png" border="0" usemap="#aclassNeuronGraph_a1c8deb90cf431df071765a400ddb144c_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a1c8deb90cf431df071765a400ddb144c_icgraph" id="aclassNeuronGraph_a1c8deb90cf431df071765a400ddb144c_icgraph">
<area shape="rect" title="Reads a neuron file, automatically detecting the format." alt="" coords="399,74,581,115"/>
<area shape="rect" href="opgl__utils_8cpp.html#adda0a7f12116617440260139feb5ae46" title="Loads a neuron morphology from an SWC or UGX file." alt="" coords="219,31,298,57"/>
<area shape="rect" href="classNeuronGraph.html#a8b2d5d03d0953e5cff1edc4e396d97c2" title="Constructor that loads a neuron from file." alt="" coords="167,81,351,108"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="183,132,334,159"/>
<area shape="rect" href="neuronviewer_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title=" " alt="" coords="37,5,87,32"/>
<area shape="rect" href="opgl__utils_8cpp.html#a81fad3cb23594d5bbd0c49fbe109379b" title="Opens a file dialog and loads a neuron morphology file." alt="" coords="5,56,119,83"/>
</map>
</div>

</div>
</div>
<a id="a0d0ce27089a76553f8e4e109ffdf8183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0ce27089a76553f8e4e109ffdf8183">&#9670;&nbsp;</a></span>removeSomaSegment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, <a class="el" href="structSWCNode.html">SWCNode</a>&gt; NeuronGraph::removeSomaSegment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Removes the soma segment from the current graph </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a0d0ce27089a76553f8e4e109ffdf8183_cgraph.png" border="0" usemap="#aclassNeuronGraph_a0d0ce27089a76553f8e4e109ffdf8183_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a0d0ce27089a76553f8e4e109ffdf8183_cgraph" id="aclassNeuronGraph_a0d0ce27089a76553f8e4e109ffdf8183_cgraph">
<area shape="rect" title=" " alt="" coords="5,29,241,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a0d0ce27089a76553f8e4e109ffdf8183_icgraph.png" border="0" usemap="#aclassNeuronGraph_a0d0ce27089a76553f8e4e109ffdf8183_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a0d0ce27089a76553f8e4e109ffdf8183_icgraph" id="aclassNeuronGraph_a0d0ce27089a76553f8e4e109ffdf8183_icgraph">
<area shape="rect" title=" " alt="" coords="204,29,440,56"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,29,156,56"/>
</map>
</div>

</div>
</div>
<a id="aed5eb4290d85b7a134f95fa5b453ba50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5eb4290d85b7a134f95fa5b453ba50">&#9670;&nbsp;</a></span>removeSomaSegment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; NeuronGraph::removeSomaSegment </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputNodes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the soma segment from a set of nodes. </p>
<p>Removes multiple soma nodes and replaces them with a single averaged soma.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputNodes</td><td>The set of nodes to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new set of nodes with the soma segment removed</dd></dl>
<p>This method identifies and removes the soma segment (multiple connected type 1 nodes) and replaces it with a single representative soma node at the average position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputNodes</td><td>The input map of SWC nodes containing multiple soma nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new map of SWC nodes with a single soma node at ID 1</dd></dl>
<p>This method processes neuron morphologies that have multiple soma nodes (soma segments) and consolidates them into a single soma node. The process involves:</p><ol type="1">
<li>Identifying all soma nodes (type == 1)</li>
<li>Computing the average position and radius of all soma nodes</li>
<li>Creating a new soma node with ID 1 at the averaged location</li>
<li>Reassigning all non-soma nodes with new sequential IDs starting from 2</li>
<li>Updating parent-child relationships to connect to the new soma</li>
<li>Ensuring topological sorting of the result</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>If no soma nodes are found, returns the input unchanged </dd>
<dd>
The resulting soma always has ID 1 and parent ID -1 (root) </dd>
<dd>
All nodes originally connected to any soma will be connected to the new soma</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#abc081d9ef1972cbc262571246698f0f2" title="Checks if the node set contains a soma segment.">hasSomaSegment()</a> to detect if soma segments exist </dd>
<dd>
<a class="el" href="classNeuronGraph.html#ab66e25466d6c0b228b95c118963e7cb0" title="Sorts nodes topologically using Kahn&#39;s algorithm.">topologicalSort()</a> for ensuring proper node ordering </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_aed5eb4290d85b7a134f95fa5b453ba50_cgraph.png" border="0" usemap="#aclassNeuronGraph_aed5eb4290d85b7a134f95fa5b453ba50_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_aed5eb4290d85b7a134f95fa5b453ba50_cgraph" id="aclassNeuronGraph_aed5eb4290d85b7a134f95fa5b453ba50_cgraph">
<area shape="rect" title="Removes the soma segment from a set of nodes." alt="" coords="5,78,241,105"/>
<area shape="rect" href="classNeuronGraph.html#a0a94b95b0afc5d98590e631f963a970d" title=" " alt="" coords="290,29,482,71"/>
<area shape="rect" href="classNeuronGraph.html#a096f5d8b9231d0b27f0a60a694db41d3" title=" " alt="" coords="289,119,483,146"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_aed5eb4290d85b7a134f95fa5b453ba50_icgraph.png" border="0" usemap="#aclassNeuronGraph_aed5eb4290d85b7a134f95fa5b453ba50_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_aed5eb4290d85b7a134f95fa5b453ba50_icgraph" id="aclassNeuronGraph_aed5eb4290d85b7a134f95fa5b453ba50_icgraph">
<area shape="rect" title="Removes the soma segment from a set of nodes." alt="" coords="104,5,340,32"/>
<area shape="rect" href="extracttrunks_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="5,5,56,32"/>
</map>
</div>

</div>
</div>
<a id="a4fbcfc32da26b3bc0fe7211ee0b08237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbcfc32da26b3bc0fe7211ee0b08237">&#9670;&nbsp;</a></span>setNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NeuronGraph::setNodes </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the current set of nodes in the graph. </p>
<p>Sets the nodes of the graph, replacing any existing nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>New set of nodes to use</td></tr>
  </table>
  </dd>
</dl>
<p>This method clears the current graph and rebuilds it using the provided nodes. It automatically updates the internal adjacency list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>A map containing SWC nodes indexed by their IDs</td></tr>
  </table>
  </dd>
</dl>
<p>This method clears the current graph data and repopulates it with the provided node set. It rebuilds all parent-child relationships from scratch.</p>
<dl class="section note"><dt>Note</dt><dd>This is equivalent to reconstructing the graph with new data </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a453e31c723b0dc9d692d8663d93be51a" title="Adds a single node to the graph.">addNode(const SWCNode&amp; node)</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a4fbcfc32da26b3bc0fe7211ee0b08237_icgraph.png" border="0" usemap="#aclassNeuronGraph_a4fbcfc32da26b3bc0fe7211ee0b08237_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a4fbcfc32da26b3bc0fe7211ee0b08237_icgraph" id="aclassNeuronGraph_a4fbcfc32da26b3bc0fe7211ee0b08237_icgraph">
<area shape="rect" title="Replaces the current set of nodes in the graph." alt="" coords="607,60,769,86"/>
<area shape="rect" href="callbacks_8cpp.html#a0b9e239c8889734711f29fe45551605b" title="Handles keyboard input events for the neuron viewer." alt="" coords="104,34,199,61"/>
<area shape="rect" href="opgl__utils_8cpp.html#adda0a7f12116617440260139feb5ae46" title="Loads a neuron morphology from an SWC or UGX file." alt="" coords="444,34,523,61"/>
<area shape="rect" href="extracttrunks_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="458,85,509,112"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="408,136,559,162"/>
<area shape="rect" href="neuronviewer_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title=" " alt="" coords="5,60,56,86"/>
<area shape="rect" href="opgl__utils_8cpp.html#a81fad3cb23594d5bbd0c49fbe109379b" title="Opens a file dialog and loads a neuron morphology file." alt="" coords="247,34,360,61"/>
</map>
</div>

</div>
</div>
<a id="a6b0c1b97c8866106d3bb7f803b94f6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0c1b97c8866106d3bb7f803b94f6f4">&#9670;&nbsp;</a></span>setSoma() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, <a class="el" href="structSWCNode.html">SWCNode</a>&gt; NeuronGraph::setSoma </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Adds a soma node to the current graph if none exists </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a6b0c1b97c8866106d3bb7f803b94f6f4_cgraph.png" border="0" usemap="#aclassNeuronGraph_a6b0c1b97c8866106d3bb7f803b94f6f4_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a6b0c1b97c8866106d3bb7f803b94f6f4_cgraph" id="aclassNeuronGraph_a6b0c1b97c8866106d3bb7f803b94f6f4_cgraph">
<area shape="rect" title=" " alt="" coords="5,29,164,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a6b0c1b97c8866106d3bb7f803b94f6f4_icgraph.png" border="0" usemap="#aclassNeuronGraph_a6b0c1b97c8866106d3bb7f803b94f6f4_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a6b0c1b97c8866106d3bb7f803b94f6f4_icgraph" id="aclassNeuronGraph_a6b0c1b97c8866106d3bb7f803b94f6f4_icgraph">
<area shape="rect" title=" " alt="" coords="204,29,363,56"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,29,156,56"/>
</map>
</div>

</div>
</div>
<a id="a4da98a459bd4ddaa00df5ed08bc80477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da98a459bd4ddaa00df5ed08bc80477">&#9670;&nbsp;</a></span>setSoma() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; NeuronGraph::setSoma </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a soma node if none exists. </p>
<p>Assigns a soma node to a neuron morphology that lacks one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The set of nodes to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new set of nodes with a soma node added if needed</dd></dl>
<p>If no soma (type 1) node is present, this method adds one at the root position of the neuron tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>The input map of SWC nodes missing a soma </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new map of SWC nodes with a soma node assigned</dd></dl>
<p>This method addresses neuron morphologies that are missing a soma (cell body) by converting the first root node found (pid == -1) into a soma node (type = 1).</p>
<p>The method follows this logic:</p><ol type="1">
<li>First checks if a soma already exists using <a class="el" href="classNeuronGraph.html#a84a4ee923b6547a3d2fa7c8953932ed0" title="Checks if the node set is missing a soma.">isSomaMissing()</a></li>
<li>If soma is present, returns the input unchanged</li>
<li>If soma is missing, searches for the first root node (pid == -1)</li>
<li>Converts the root node's type to 1 (soma type)</li>
<li>Prints a confirmation message with the assigned node ID</li>
</ol>
<p>This operation is essential for:</p><ul>
<li>Ensuring every neuron has exactly one soma for proper analysis</li>
<li>Correcting incomplete neuron reconstructions</li>
<li>Preparing neuron data for mesh generation algorithms</li>
<li>Maintaining consistency with neuron morphology standards</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If no root node is found, prints a warning and returns input unchanged </dd>
<dd>
Only the first root node encountered is converted to soma </dd>
<dd>
The node's position and other properties remain unchanged</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If multiple root nodes exist, only the first one becomes the soma</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a84a4ee923b6547a3d2fa7c8953932ed0" title="Checks if the node set is missing a soma.">isSomaMissing()</a> to detect if soma assignment is needed </dd>
<dd>
<a class="el" href="classNeuronGraph.html#a48d21c08d8a35dd270a0aa8032c4fe35" title="Applies standard preprocessing steps to a set of nodes.">preprocess()</a> which automatically calls this method when needed </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a4da98a459bd4ddaa00df5ed08bc80477_cgraph.png" border="0" usemap="#aclassNeuronGraph_a4da98a459bd4ddaa00df5ed08bc80477_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a4da98a459bd4ddaa00df5ed08bc80477_cgraph" id="aclassNeuronGraph_a4da98a459bd4ddaa00df5ed08bc80477_cgraph">
<area shape="rect" title="Adds a soma node if none exists." alt="" coords="5,29,164,56"/>
<area shape="rect" href="classNeuronGraph.html#ae25c92d56c3019385447d3dc7ab86346" title=" " alt="" coords="212,29,408,56"/>
</map>
</div>

</div>
</div>
<a id="abff93693953850f3bbda6dd5e694de08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff93693953850f3bbda6dd5e694de08">&#9670;&nbsp;</a></span>splitEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, <a class="el" href="structSWCNode.html">SWCNode</a>&gt; NeuronGraph::splitEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Splits all edges in the current graph </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_abff93693953850f3bbda6dd5e694de08_cgraph.png" border="0" usemap="#aclassNeuronGraph_abff93693953850f3bbda6dd5e694de08_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_abff93693953850f3bbda6dd5e694de08_cgraph" id="aclassNeuronGraph_abff93693953850f3bbda6dd5e694de08_cgraph">
<area shape="rect" title=" " alt="" coords="5,29,173,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_abff93693953850f3bbda6dd5e694de08_icgraph.png" border="0" usemap="#aclassNeuronGraph_abff93693953850f3bbda6dd5e694de08_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_abff93693953850f3bbda6dd5e694de08_icgraph" id="aclassNeuronGraph_abff93693953850f3bbda6dd5e694de08_icgraph">
<area shape="rect" title=" " alt="" coords="431,31,599,57"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,5,156,32"/>
<area shape="rect" href="classNeuronGraph.html#acde3c34e7d73fd00635d4fef5a9fcb3d" title="Applies edge splitting N times recursively." alt="" coords="204,56,383,83"/>
<area shape="rect" href="splitrefineSET_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="55,56,106,83"/>
</map>
</div>

</div>
</div>
<a id="a4dd02c37f81fc7d5cfbb929bd25e1fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd02c37f81fc7d5cfbb929bd25e1fa2">&#9670;&nbsp;</a></span>splitEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; NeuronGraph::splitEdges </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits all edges in the graph by inserting midpoint nodes. </p>
<p>Splits all edges in the neuron by inserting midpoint nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The set of nodes to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new set of nodes with edges split</dd></dl>
<p>This method inserts a new node at the midpoint of each edge, effectively doubling the number of edges while preserving the overall shape of the neuron.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>The input map of SWC nodes to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new map of SWC nodes with midpoint nodes inserted on all edges</dd></dl>
<p>This method performs edge subdivision by inserting a new node at the midpoint of every parent-child edge in the neuron morphology. The process involves:</p><ol type="1">
<li>Creating a midpoint node for each parent-child relationship</li>
<li>Positioning the midpoint at the average coordinates of parent and child</li>
<li>Setting the midpoint radius as the average of parent and child radii</li>
<li>Updating the topology so child nodes connect through their midpoints</li>
<li>Ensuring topological sorting of the final result</li>
</ol>
<p>This operation effectively doubles the resolution of the neuron morphology, which is useful for:</p><ul>
<li>Mesh refinement operations</li>
<li>Improved geometric accuracy in simulations</li>
<li>Smoother interpolation between neuron segments</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>New node IDs are assigned sequentially starting from the highest existing ID + 1 </dd>
<dd>
Midpoint nodes inherit the type of their child node </dd>
<dd>
Root nodes (pid == -1) are not affected by this operation</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#acde3c34e7d73fd00635d4fef5a9fcb3d" title="Applies edge splitting N times recursively.">splitEdgesN()</a> for performing multiple iterations of edge splitting </dd>
<dd>
<a class="el" href="classNeuronGraph.html#ab66e25466d6c0b228b95c118963e7cb0" title="Sorts nodes topologically using Kahn&#39;s algorithm.">topologicalSort()</a> for ensuring proper node ordering </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a4dd02c37f81fc7d5cfbb929bd25e1fa2_cgraph.png" border="0" usemap="#aclassNeuronGraph_a4dd02c37f81fc7d5cfbb929bd25e1fa2_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a4dd02c37f81fc7d5cfbb929bd25e1fa2_cgraph" id="aclassNeuronGraph_a4dd02c37f81fc7d5cfbb929bd25e1fa2_cgraph">
<area shape="rect" title="Splits all edges in the graph by inserting midpoint nodes." alt="" coords="5,78,173,105"/>
<area shape="rect" href="classNeuronGraph.html#a0a94b95b0afc5d98590e631f963a970d" title=" " alt="" coords="222,29,414,71"/>
<area shape="rect" href="classNeuronGraph.html#a096f5d8b9231d0b27f0a60a694db41d3" title=" " alt="" coords="221,119,415,146"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a4dd02c37f81fc7d5cfbb929bd25e1fa2_icgraph.png" border="0" usemap="#aclassNeuronGraph_a4dd02c37f81fc7d5cfbb929bd25e1fa2_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a4dd02c37f81fc7d5cfbb929bd25e1fa2_icgraph" id="aclassNeuronGraph_a4dd02c37f81fc7d5cfbb929bd25e1fa2_icgraph">
<area shape="rect" title="Splits all edges in the graph by inserting midpoint nodes." alt="" coords="104,5,272,32"/>
<area shape="rect" href="splitrefine_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="5,5,56,32"/>
</map>
</div>

</div>
</div>
<a id="acde3c34e7d73fd00635d4fef5a9fcb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde3c34e7d73fd00635d4fef5a9fcb3d">&#9670;&nbsp;</a></span>splitEdgesN() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &gt; NeuronGraph::splitEdgesN </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies edge splitting N times recursively. </p>
<p>Performs N iterations of edge splitting on the neuron morphology.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The set of nodes to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Number of times to split the edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of node sets, where each element represents the result of i+1 splits (i = 0 to N-1)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>The input map of SWC nodes to process </td></tr>
    <tr><td class="paramname">N</td><td>The number of edge splitting iterations to perform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the node sets after each iteration of splitting</dd></dl>
<p>This method applies the <a class="el" href="classNeuronGraph.html#a4dd02c37f81fc7d5cfbb929bd25e1fa2" title="Splits all edges in the graph by inserting midpoint nodes.">splitEdges()</a> operation N times in sequence, where each iteration uses the result of the previous iteration as input. This creates progressively finer subdivisions of the neuron morphology.</p>
<p>The returned vector contains N maps, where:</p><ul>
<li>splits[0] contains the result after 1 iteration</li>
<li>splits[1] contains the result after 2 iterations</li>
<li>splits[N-1] contains the result after N iterations</li>
</ul>
<p>After N iterations, the number of nodes grows exponentially, with each iteration approximately doubling the number of edges (and thus nodes).</p>
<p>Use cases:</p><ul>
<li>Progressive mesh refinement for adaptive simulations</li>
<li>Creating multiple levels of detail for the same neuron</li>
<li>Analyzing convergence properties of numerical methods</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Each iteration significantly increases the number of nodes </dd>
<dd>
Memory usage grows exponentially with N </dd>
<dd>
Consider memory constraints when choosing large values of N</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a4dd02c37f81fc7d5cfbb929bd25e1fa2" title="Splits all edges in the graph by inserting midpoint nodes.">splitEdges()</a> for single iteration edge splitting </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_acde3c34e7d73fd00635d4fef5a9fcb3d_cgraph.png" border="0" usemap="#aclassNeuronGraph_acde3c34e7d73fd00635d4fef5a9fcb3d_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_acde3c34e7d73fd00635d4fef5a9fcb3d_cgraph" id="aclassNeuronGraph_acde3c34e7d73fd00635d4fef5a9fcb3d_cgraph">
<area shape="rect" title="Applies edge splitting N times recursively." alt="" coords="5,29,184,56"/>
<area shape="rect" href="classNeuronGraph.html#abff93693953850f3bbda6dd5e694de08" title=" " alt="" coords="232,29,400,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_acde3c34e7d73fd00635d4fef5a9fcb3d_icgraph.png" border="0" usemap="#aclassNeuronGraph_acde3c34e7d73fd00635d4fef5a9fcb3d_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_acde3c34e7d73fd00635d4fef5a9fcb3d_icgraph" id="aclassNeuronGraph_acde3c34e7d73fd00635d4fef5a9fcb3d_icgraph">
<area shape="rect" title="Applies edge splitting N times recursively." alt="" coords="204,31,383,57"/>
<area shape="rect" href="splitrefineSET_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="55,5,106,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,56,156,83"/>
</map>
</div>

</div>
</div>
<a id="a5aeb1a2193d8a712338836d5c9ce53f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aeb1a2193d8a712338836d5c9ce53f4">&#9670;&nbsp;</a></span>splitEdgesN() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::map&lt;int, <a class="el" href="structSWCNode.html">SWCNode</a>&gt; &gt; NeuronGraph::splitEdgesN </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Applies edge splitting N times to the current graph </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a5aeb1a2193d8a712338836d5c9ce53f4_cgraph.png" border="0" usemap="#aclassNeuronGraph_a5aeb1a2193d8a712338836d5c9ce53f4_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a5aeb1a2193d8a712338836d5c9ce53f4_cgraph" id="aclassNeuronGraph_a5aeb1a2193d8a712338836d5c9ce53f4_cgraph">
<area shape="rect" title=" " alt="" coords="5,29,184,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a5aeb1a2193d8a712338836d5c9ce53f4_icgraph.png" border="0" usemap="#aclassNeuronGraph_a5aeb1a2193d8a712338836d5c9ce53f4_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a5aeb1a2193d8a712338836d5c9ce53f4_icgraph" id="aclassNeuronGraph_a5aeb1a2193d8a712338836d5c9ce53f4_icgraph">
<area shape="rect" title=" " alt="" coords="5,29,184,56"/>
</map>
</div>

</div>
</div>
<a id="aedde45f3cf0e5a3bb8cec88b864580a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedde45f3cf0e5a3bb8cec88b864580a6">&#9670;&nbsp;</a></span>swc2ugx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NeuronGraph::swc2ugx </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outputfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an SWC file to UGX format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputfile</td><td>Path to the input SWC file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputfile</td><td>Path for the output UGX file</td></tr>
  </table>
  </dd>
</dl>
<p>This is a convenience method that combines <a class="el" href="classNeuronGraph.html#a8ee6517767cd316da4474cb55c67307f" title="Reads neuron data from an SWC file.">readFromFile()</a> and <a class="el" href="classNeuronGraph.html#a938d33cc1ee5a5abc291c555e0a60ad5" title="Writes a set of nodes to a UGX file.">writeToFileUGX()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputfile</td><td>Path to the input SWC file </td></tr>
    <tr><td class="paramname">outputfile</td><td>Path to the output UGX file</td></tr>
  </table>
  </dd>
</dl>
<p>This static utility method provides convenient SWC to UGX format conversion. It creates a temporary <a class="el" href="classNeuronGraph.html" title="Class for representing and processing neuron morphology graphs.">NeuronGraph</a> instance, loads the SWC data, and exports it in UGX format suitable for mesh generation and finite element analysis.</p>
<dl class="section note"><dt>Note</dt><dd>This is a static method that can be called without a <a class="el" href="classNeuronGraph.html" title="Class for representing and processing neuron morphology graphs.">NeuronGraph</a> instance</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a31ec77a2f3c9e69317c30366560761f5" title="Converts a UGX file to SWC format.">ugx2swc(const std::string&amp; inputfile, const std::string&amp; outputfile)</a> for reverse conversion </dd>
<dd>
<a class="el" href="classNeuronGraph.html#a938d33cc1ee5a5abc291c555e0a60ad5" title="Writes a set of nodes to a UGX file.">writeToFileUGX()</a> for UGX output functionality </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_aedde45f3cf0e5a3bb8cec88b864580a6_icgraph.png" border="0" usemap="#aclassNeuronGraph_aedde45f3cf0e5a3bb8cec88b864580a6_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_aedde45f3cf0e5a3bb8cec88b864580a6_icgraph" id="aclassNeuronGraph_aedde45f3cf0e5a3bb8cec88b864580a6_icgraph">
<area shape="rect" title="Converts an SWC file to UGX format." alt="" coords="204,5,363,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,5,156,32"/>
</map>
</div>

</div>
</div>
<a id="a096f5d8b9231d0b27f0a60a694db41d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096f5d8b9231d0b27f0a60a694db41d3">&#9670;&nbsp;</a></span>topologicalSort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, <a class="el" href="structSWCNode.html">SWCNode</a>&gt; NeuronGraph::topologicalSort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Sorts the current graph's nodes topologically </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a096f5d8b9231d0b27f0a60a694db41d3_cgraph.png" border="0" usemap="#aclassNeuronGraph_a096f5d8b9231d0b27f0a60a694db41d3_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a096f5d8b9231d0b27f0a60a694db41d3_cgraph" id="aclassNeuronGraph_a096f5d8b9231d0b27f0a60a694db41d3_cgraph">
<area shape="rect" title=" " alt="" coords="5,29,199,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a096f5d8b9231d0b27f0a60a694db41d3_icgraph.png" border="0" usemap="#aclassNeuronGraph_a096f5d8b9231d0b27f0a60a694db41d3_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a096f5d8b9231d0b27f0a60a694db41d3_icgraph" id="aclassNeuronGraph_a096f5d8b9231d0b27f0a60a694db41d3_icgraph">
<area shape="rect" title=" " alt="" coords="388,56,581,83"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="147,5,297,32"/>
<area shape="rect" href="classNeuronGraph.html#aed5eb4290d85b7a134f95fa5b453ba50" title="Removes the soma segment from a set of nodes." alt="" coords="104,56,340,83"/>
<area shape="rect" href="classNeuronGraph.html#a4dd02c37f81fc7d5cfbb929bd25e1fa2" title="Splits all edges in the graph by inserting midpoint nodes." alt="" coords="138,107,306,133"/>
<area shape="rect" href="extracttrunks_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="5,56,56,83"/>
<area shape="rect" href="splitrefine_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="5,107,56,133"/>
</map>
</div>

</div>
</div>
<a id="ab66e25466d6c0b228b95c118963e7cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66e25466d6c0b228b95c118963e7cb0">&#9670;&nbsp;</a></span>topologicalSort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; NeuronGraph::topologicalSort </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts nodes topologically using Kahn's algorithm. </p>
<p>Performs topological sorting of neuron nodes to ensure proper parent-child ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The set of nodes to sort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new map of nodes sorted in topological order</dd></dl>
<p>This method ensures that parent nodes always appear before their children in the resulting sequence, which is important for many processing steps.</p>
<dl class="section note"><dt>Note</dt><dd>If the graph contains cycles, the behavior is undefined. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Topological_sorting#Kahn's_algorithm">https://en.wikipedia.org/wiki/Topological_sorting#Kahn's_algorithm</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>The input map of SWC nodes to sort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new map of SWC nodes with reassigned IDs in topological order</dd></dl>
<p>This method implements Kahn's algorithm for topological sorting to ensure that all parent nodes have smaller IDs than their children. The algorithm:</p><ol type="1">
<li>Builds an adjacency list and calculates in-degrees for all nodes</li>
<li>Starts with nodes having zero in-degree (root nodes)</li>
<li>Processes nodes in breadth-first order, updating in-degrees</li>
<li>Reassigns node IDs sequentially (1, 2, 3, ...) based on topological order</li>
<li>Updates parent IDs to maintain correct relationships</li>
</ol>
<p>Topological sorting is essential for:</p><ul>
<li>Ensuring proper tree traversal algorithms work correctly</li>
<li>Maintaining consistency in neuron analysis operations</li>
<li>Enabling efficient parent-to-child processing</li>
<li>Supporting mesh generation algorithms that rely on ordered traversal</li>
</ul>
<p>The resulting neuron will have:</p><ul>
<li>Root nodes (soma) with the smallest IDs</li>
<li>All parent nodes having IDs smaller than their children</li>
<li>Sequential ID numbering starting from 1</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This method creates entirely new node IDs while preserving topology </dd>
<dd>
The original node IDs are completely replaced </dd>
<dd>
Parent-child relationships are preserved but with new ID mappings</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a7b7eae0aeccf7e7aec8f3cab6008f37c" title="Checks if a set of nodes is topologically sorted.">isTopologicallySorted()</a> to check if sorting is needed </dd></dl>

</div>
</div>
<a id="a31ec77a2f3c9e69317c30366560761f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ec77a2f3c9e69317c30366560761f5">&#9670;&nbsp;</a></span>ugx2swc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NeuronGraph::ugx2swc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outputfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a UGX file to SWC format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputfile</td><td>Path to the input UGX file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputfile</td><td>Path for the output SWC file</td></tr>
  </table>
  </dd>
</dl>
<p>This is a convenience method that combines <a class="el" href="classNeuronGraph.html#a8742e842a6ce2eb1981d36ba9a8317fb" title="Reads neuron data from a UGX file.">readFromFileUGX()</a> and <a class="el" href="classNeuronGraph.html#a4b1a573b34c20a37ec3ca5bdf530bdcb" title="Writes a set of nodes to an SWC file.">writeToFile()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputfile</td><td>Path to the input UGX file </td></tr>
    <tr><td class="paramname">outputfile</td><td>Path to the output SWC file</td></tr>
  </table>
  </dd>
</dl>
<p>This static utility method provides convenient UGX to SWC format conversion. It creates a temporary <a class="el" href="classNeuronGraph.html" title="Class for representing and processing neuron morphology graphs.">NeuronGraph</a> instance, loads the UGX data, and exports it in standard SWC format for compatibility with neuron analysis tools.</p>
<dl class="section note"><dt>Note</dt><dd>This is a static method that can be called without a <a class="el" href="classNeuronGraph.html" title="Class for representing and processing neuron morphology graphs.">NeuronGraph</a> instance</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#aedde45f3cf0e5a3bb8cec88b864580a6" title="Converts an SWC file to UGX format.">swc2ugx(const std::string&amp; inputfile, const std::string&amp; outputfile)</a> for reverse conversion </dd>
<dd>
<a class="el" href="classNeuronGraph.html#a4b1a573b34c20a37ec3ca5bdf530bdcb" title="Writes a set of nodes to an SWC file.">writeToFile()</a> for SWC output functionality </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a31ec77a2f3c9e69317c30366560761f5_icgraph.png" border="0" usemap="#aclassNeuronGraph_a31ec77a2f3c9e69317c30366560761f5_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a31ec77a2f3c9e69317c30366560761f5_icgraph" id="aclassNeuronGraph_a31ec77a2f3c9e69317c30366560761f5_icgraph">
<area shape="rect" title="Converts a UGX file to SWC format." alt="" coords="204,5,363,32"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="5,5,156,32"/>
</map>
</div>

</div>
</div>
<a id="a4b1a573b34c20a37ec3ca5bdf530bdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1a573b34c20a37ec3ca5bdf530bdcb">&#9670;&nbsp;</a></span>writeToFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NeuronGraph::writeToFile </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a set of nodes to an SWC file. </p>
<p>Writes neuron morphology data to an SWC format file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The nodes to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to the output file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The file will be overwritten if it already exists</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>Map of SWC nodes to write to file </td></tr>
    <tr><td class="paramname">filename</td><td>Output file path for the SWC data</td></tr>
  </table>
  </dd>
</dl>
<p>This method exports neuron morphology data in the standard SWC format. Nodes are written in sorted order by ID to ensure consistent output. Each line contains: ID, type, x, y, z, radius, parent_ID.</p>
<p>The output format is compatible with standard neuron analysis tools and can be read back using <a class="el" href="classNeuronGraph.html#a8ee6517767cd316da4474cb55c67307f" title="Reads neuron data from an SWC file.">readFromFile()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If output file cannot be opened, an error message is printed and method returns </dd>
<dd>
Prints confirmation message upon successful completion</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a8ee6517767cd316da4474cb55c67307f" title="Reads neuron data from an SWC file.">readFromFile(const std::string&amp; filename)</a> for reading SWC files </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a4b1a573b34c20a37ec3ca5bdf530bdcb_icgraph.png" border="0" usemap="#aclassNeuronGraph_a4b1a573b34c20a37ec3ca5bdf530bdcb_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a4b1a573b34c20a37ec3ca5bdf530bdcb_icgraph" id="aclassNeuronGraph_a4b1a573b34c20a37ec3ca5bdf530bdcb_icgraph">
<area shape="rect" title="Writes a set of nodes to an SWC file." alt="" coords="303,56,473,83"/>
<area shape="rect" href="callbacks_8cpp.html#a0b9e239c8889734711f29fe45551605b" title="Handles keyboard input events for the neuron viewer." alt="" coords="132,5,227,32"/>
<area shape="rect" href="extracttrunks_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="154,56,205,83"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="104,107,255,133"/>
<area shape="rect" href="neuronviewer_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title=" " alt="" coords="5,5,56,32"/>
</map>
</div>

</div>
</div>
<a id="a0dec1b5ec2012af3aa6cb50ce2c08941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dec1b5ec2012af3aa6cb50ce2c08941">&#9670;&nbsp;</a></span>writeToFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NeuronGraph::writeToFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Writes the current graph's nodes to an SWC file </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a0dec1b5ec2012af3aa6cb50ce2c08941_cgraph.png" border="0" usemap="#aclassNeuronGraph_a0dec1b5ec2012af3aa6cb50ce2c08941_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_a0dec1b5ec2012af3aa6cb50ce2c08941_cgraph" id="aclassNeuronGraph_a0dec1b5ec2012af3aa6cb50ce2c08941_cgraph">
<area shape="rect" title=" " alt="" coords="5,29,176,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a0dec1b5ec2012af3aa6cb50ce2c08941_icgraph.png" border="0" usemap="#aclassNeuronGraph_a0dec1b5ec2012af3aa6cb50ce2c08941_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a0dec1b5ec2012af3aa6cb50ce2c08941_icgraph" id="aclassNeuronGraph_a0dec1b5ec2012af3aa6cb50ce2c08941_icgraph">
<area shape="rect" title=" " alt="" coords="5,29,176,56"/>
</map>
</div>

</div>
</div>
<a id="a938d33cc1ee5a5abc291c555e0a60ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938d33cc1ee5a5abc291c555e0a60ad5">&#9670;&nbsp;</a></span>writeToFileUGX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NeuronGraph::writeToFileUGX </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, <a class="el" href="structSWCNode.html">SWCNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a set of nodes to a UGX file. </p>
<p>Writes neuron morphology data to a UGX file format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeSet</td><td>The nodes to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to the output file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The file will be overwritten if it already exists</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeSet</td><td>Map of SWC nodes to be written, where key is node ID and value is <a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> object </td></tr>
    <tr><td class="paramname">filename</td><td>Path to the output UGX file</td></tr>
  </table>
  </dd>
</dl>
<p>This method converts the internal neuron representation into the UGX file format, which is compatible with the UG4 simulation framework. The UGX format is an XML-based format that can represent complex graph structures with additional attributes.</p>
<p>The output UGX file includes:</p><ul>
<li>3D vertex coordinates for each node</li>
<li>Edge connectivity based on parent-child relationships</li>
<li>Node diameters as vertex attributes</li>
<li>Subset definitions for different neuron components (soma, axon, dendrites, etc.)</li>
</ul>
<p>The method performs the following steps:</p><ol type="1">
<li>Extracts node positions, diameters, and connectivity from the input node set</li>
<li>Creates a mapping between node IDs and internal indices</li>
<li>Organizes nodes into subsets based on their type (soma, axon, dendrites, etc.)</li>
<li>Constructs the UGX XML structure with proper formatting</li>
<li>Writes the XML data to the specified file</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The method preserves the 3D structure and topological relationships of the neuron </dd>
<dd>
If the file cannot be written, an error message is printed to stderr </dd>
<dd>
The method automatically handles different SWC node types (soma=1, axon=2, etc.) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classNeuronGraph.html#a8742e842a6ce2eb1981d36ba9a8317fb" title="Reads neuron data from a UGX file.">readFromFileUGX()</a> for the corresponding import functionality </dd>
<dd>
<a href="https://github.com/UG4/ug4">https://github.com/UG4/ug4</a> for more information about the UGX format </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_a938d33cc1ee5a5abc291c555e0a60ad5_icgraph.png" border="0" usemap="#aclassNeuronGraph_a938d33cc1ee5a5abc291c555e0a60ad5_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_a938d33cc1ee5a5abc291c555e0a60ad5_icgraph" id="aclassNeuronGraph_a938d33cc1ee5a5abc291c555e0a60ad5_icgraph">
<area shape="rect" title="Writes a set of nodes to a UGX file." alt="" coords="303,56,501,83"/>
<area shape="rect" href="callbacks_8cpp.html#a0b9e239c8889734711f29fe45551605b" title="Handles keyboard input events for the neuron viewer." alt="" coords="132,5,227,32"/>
<area shape="rect" href="splitrefineSET_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97" title=" " alt="" coords="154,56,205,83"/>
<area shape="rect" href="bindings_8cpp.html#aae7648d27183e458e522ad3086719fde" title="Python module definition for neurongraph." alt="" coords="104,107,255,133"/>
<area shape="rect" href="neuronviewer_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title=" " alt="" coords="5,5,56,32"/>
</map>
</div>

</div>
</div>
<a id="aa4db233a8438b8eb45241f79c3a8cfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4db233a8438b8eb45241f79c3a8cfe4">&#9670;&nbsp;</a></span>writeToFileUGX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NeuronGraph::writeToFileUGX </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Writes the current graph's nodes to a UGX file </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_aa4db233a8438b8eb45241f79c3a8cfe4_cgraph.png" border="0" usemap="#aclassNeuronGraph_aa4db233a8438b8eb45241f79c3a8cfe4_cgraph" alt=""/></div>
<map name="aclassNeuronGraph_aa4db233a8438b8eb45241f79c3a8cfe4_cgraph" id="aclassNeuronGraph_aa4db233a8438b8eb45241f79c3a8cfe4_cgraph">
<area shape="rect" title=" " alt="" coords="5,29,204,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classNeuronGraph_aa4db233a8438b8eb45241f79c3a8cfe4_icgraph.png" border="0" usemap="#aclassNeuronGraph_aa4db233a8438b8eb45241f79c3a8cfe4_icgraph" alt=""/></div>
<map name="aclassNeuronGraph_aa4db233a8438b8eb45241f79c3a8cfe4_icgraph" id="aclassNeuronGraph_aa4db233a8438b8eb45241f79c3a8cfe4_icgraph">
<area shape="rect" title=" " alt="" coords="5,29,204,56"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae9cbc0c7feb5dcfbc415fb65ca5f782a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cbc0c7feb5dcfbc415fb65ca5f782a">&#9670;&nbsp;</a></span>edges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, std::vector&lt;int&gt; &gt; NeuronGraph::edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjacency list representation of the neuron graph. </p>

</div>
</div>
<a id="a312adb405dceafb6b1a736bd8e4ded88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312adb405dceafb6b1a736bd8e4ded88">&#9670;&nbsp;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int,<a class="el" href="structSWCNode.html">SWCNode</a>&gt; NeuronGraph::nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map of node IDs to <a class="el" href="structSWCNode.html" title="Structure representing a single node in an SWC neuron morphology.">SWCNode</a> objects. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/project/<a class="el" href="neurongraph_8h_source.html">neurongraph.h</a></li>
<li>src/<a class="el" href="neurongraph_8cpp.html">neurongraph.cpp</a></li>
<li>src/<a class="el" href="neuronoperations_8cpp.html">neuronoperations.cpp</a></li>
<li>src/<a class="el" href="neurontrunks_8cpp.html">neurontrunks.cpp</a></li>
<li>src/<a class="el" href="neuronugx_8cpp.html">neuronugx.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classNeuronGraph.html">NeuronGraph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
